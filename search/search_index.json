{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XLB's home","text":""},{"location":"#xlb-a-hardware-accelerated-differentiable-lattice-boltzmann-simulation-framework-based-on-jax-for-physics-based-machine-learning","title":"XLB: A Hardware-Accelerated Differentiable Lattice Boltzmann Simulation Framework based on JAX for Physics-based Machine Learning","text":"<p>XLB (Accelerated LB) is a fully differentiable 2D/3D Lattice Boltzmann Method (LBM) solver that leverages hardware acceleration. It\u2019s built on top of the JAX library and is specifically designed to solve fluid dynamics problems in a computationally efficient and differentiable manner. Its unique combination of features positions it as an exceptionally suitable tool for applications in physics-based machine learning.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Integration with JAX Ecosystem: The solver can be easily integrated with JAX\u2019s robust ecosystem of machine learning libraries such as Flax, Haiku, Optax, and many more.</li> <li>Scalability: XLB is capable of scaling on distributed multi-GPU systems, enabling the execution of large-scale simulations with billions of voxels.</li> <li>Support for Various LBM Boundary Conditions and Kernels: XLB supports several LBM boundary conditions and collision kernels.</li> <li>User-Friendly Interface: Written entirely in Python, XLB emphasizes a highly accessible interface that allows users to extend the solver with ease and quickly set up and run new simulations.</li> <li>Leverages JAX Array and Shardmap: The solver incorporates the new JAX array unified array type and JAX shardmap, providing users with a numpy-like interface. This allows users to focus solely on the semantics, leaving performance optimizations to the compiler.</li> <li>Platform Versatility: The same XLB code can be executed on a variety of platforms including multi-core CPUs, single or multi-GPU systems, TPUs, and it also supports distributed runs on multi-GPU systems or TPU Pod slices.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation can be found here (in preparation)</p>"},{"location":"#showcase","title":"Showcase","text":"<p>The following examples showcase the capabilities of XLB:</p> <p> </p> <p>   Lid-driven Cavity flow at Re=100,000 (~25 million voxels) </p> <p> </p> <p>  DrivAer model  in a wind-tunnel using KBC Lattice Boltzmann Simulation with approx. 317 million voxels </p> <p> </p> <p>   Flow over a NACA airfoil using KBC Lattice Boltzmann Simulation with approx. 100 million voxels </p>"},{"location":"#capabilities","title":"Capabilities","text":""},{"location":"#lbm","title":"LBM","text":"<ul> <li>BGK collision model (Standard LBM collision model)</li> <li>KBC collision model (unconditionally stable for flows with high Reynolds number)</li> </ul>"},{"location":"#lattice-models","title":"Lattice Models","text":"<ul> <li>D2Q9</li> <li>D3Q19</li> <li>D3Q27 (Must be used for KBC simulation runs)</li> </ul>"},{"location":"#output","title":"Output","text":"<ul> <li>Binary and ASCII VTK output (based on PyVista library)</li> <li>Image Output</li> <li>3D mesh voxelizer using trimesh</li> </ul>"},{"location":"#boundary-conditions","title":"Boundary conditions","text":"<ul> <li> <p>Equilibrium BC: In this boundary condition, the fluid populations are assumed to be in at equilibrium. Can be used to set prescribed velocity or pressure.</p> </li> <li> <p>Full-Way Bounceback BC: In this boundary condition, the velocity of the fluid populations is reflected back to the fluid side of the boundary, resulting in zero fluid velocity at the boundary.</p> </li> <li> <p>Half-Way Bounceback BC: Similar to the Full-Way Bounceback BC, in this boundary condition, the velocity of the fluid populations is partially reflected back to the fluid side of the boundary, resulting in a non-zero fluid velocity at the boundary.</p> </li> <li> <p>Do Nothing BC: In this boundary condition, the fluid populations are allowed to pass through the boundary without any reflection or modification.</p> </li> <li> <p>Zouhe BC: This boundary condition is used to impose a prescribed velocity or pressure profile at the boundary.</p> </li> <li>Regularized BC: This boundary condition is used to impose a prescribed velocity or pressure profile at the boundary. This BC is more stable than Zouhe BC, but computationally more expensive.</li> <li>Extrapolation Outflow BC: A type of outflow boundary condition that uses extrapolation to avoid strong wave reflections.</li> </ul>"},{"location":"#compute-capabilities","title":"Compute Capabilities","text":"<ul> <li>Distributed Multi-GPU support</li> <li>JAX shard-map and JAX Array support</li> <li>Mixed-Precision support (store vs compute)</li> </ul>"},{"location":"#installation-guide","title":"Installation Guide","text":"<p>To use XLB, you must first install JAX and other dependencies using the following commands:</p> <pre><code># Please refer to https://github.com/google/jax for the latest installation documentation\n\npip install --upgrade pip\n\n# For CPU run\npip install --upgrade \"jax[cpu]\"\n\n# For GPU run\n\n# CUDA 12 and cuDNN 8.8 or newer.\npip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n\n# CUDA 11 and cuDNN 8.6 or newer.\npip install --upgrade \"jax[cuda11_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n\n# Run dependencies\npip install jmp pyvista numpy matplotlib Rtree trimesh jmp\n</code></pre> <p>Run an example:</p> <pre><code>git clone https://github.com/Autodesk/XLB\ncd XLB\nexport PYTHONPATH=.\npython3 examples/cavity2d.py\n</code></pre>"},{"location":"#citing-xlb","title":"Citing XLB","text":"<p>Accompanying publication coming soon:</p> <p>M. Ataei, H. Salehipour. XLB: Hardware-Accelerated, Scalable, and Differentiable Lattice Boltzmann Simulation Framework based on JAX. TBA</p>"},{"location":"base/","title":"XLB base","text":"<p>               Bases: <code>object</code></p> <p>LBMBase: A class that represents a base for Lattice Boltzmann Method simulation.</p>"},{"location":"base/#src.base.LBMBase--parameters","title":"Parameters","text":"<pre><code>lattice (object): The lattice object that contains the lattice structure and weights.\nomega (float): The relaxation parameter for the LBM simulation.\nnx (int): Number of grid points in the x-direction.\nny (int): Number of grid points in the y-direction.\nnz (int, optional): Number of grid points in the z-direction. Defaults to 0.\nprecision (str, optional): A string specifying the precision used for the simulation. Defaults to \"f32/f32\".\n</code></pre> Source code in <code>src/base.py</code> <pre><code>class LBMBase(object):\n    \"\"\"\n    LBMBase: A class that represents a base for Lattice Boltzmann Method simulation.\n\n    Parameters\n    ----------\n        lattice (object): The lattice object that contains the lattice structure and weights.\n        omega (float): The relaxation parameter for the LBM simulation.\n        nx (int): Number of grid points in the x-direction.\n        ny (int): Number of grid points in the y-direction.\n        nz (int, optional): Number of grid points in the z-direction. Defaults to 0.\n        precision (str, optional): A string specifying the precision used for the simulation. Defaults to \"f32/f32\".\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.omega = kwargs.get(\"omega\")\n        self.nx = kwargs.get(\"nx\")\n        self.ny = kwargs.get(\"ny\")\n        self.nz = kwargs.get(\"nz\")\n\n        self.precision = kwargs.get(\"precision\")\n        computedType, storedType = self.set_precisions(self.precision)\n        self.precisionPolicy = jmp.Policy(compute_dtype=computedType,\n                                            param_dtype=computedType, output_dtype=storedType)\n\n        self.lattice = kwargs.get(\"lattice\")\n        self.checkpointRate = kwargs.get(\"checkpoint_rate\", 0)\n        self.checkpointDir = kwargs.get(\"checkpoint_dir\", './checkpoints')\n        self.downsamplingFactor = kwargs.get(\"downsampling_factor\", 1)\n        self.printInfoRate = kwargs.get(\"print_info_rate\", 100)\n        self.ioRate = kwargs.get(\"io_rate\", 0)\n        self.returnFpost = kwargs.get(\"return_fpost\", False)\n        self.computeMLUPS = kwargs.get(\"compute_MLUPS\", False)\n        self.restore_checkpoint = kwargs.get(\"restore_checkpoint\", False)\n        self.nDevices = jax.device_count()\n        self.backend = jax.default_backend()\n\n        if self.computeMLUPS:\n            self.restore_checkpoint = False\n            self.ioRate = 0\n            self.checkpointRate = 0\n            self.printInfoRate = 0\n\n        # Check for distributed mode\n        if self.nDevices &gt; jax.local_device_count():\n            print(\"WARNING: Running in distributed mode. Make sure that jax.distributed.initialize is called before performing any JAX computations.\")\n\n        self.c = self.lattice.c\n        self.q = self.lattice.q\n        self.w = self.lattice.w\n        self.dim = self.lattice.d\n\n        # Set the checkpoint manager\n        if self.checkpointRate &gt; 0:\n            mngr_options = orb.CheckpointManagerOptions(save_interval_steps=self.checkpointRate, max_to_keep=1)\n            self.mngr = orb.CheckpointManager(self.checkpointDir, orb.PyTreeCheckpointer(), options=mngr_options)\n        else:\n            self.mngr = None\n\n        # Adjust the number of grid points in the x direction, if necessary.\n        # If the number of grid points is not divisible by the number of devices\n        # it increases the number of grid points to the next multiple of the number of devices.\n        # This is done in order to accommodate the domain sharding per XLA device\n        nx, ny, nz = kwargs.get(\"nx\"), kwargs.get(\"ny\"), kwargs.get(\"nz\")\n        if None in {nx, ny, nz}:\n            raise ValueError(\"nx, ny, and nz must be provided. For 2D examples, nz must be set to 0.\")\n        self.nx = nx\n        if nx % self.nDevices:\n            self.nx = nx + (self.nDevices - nx % self.nDevices)\n            print(\"WARNING: nx increased from {} to {} in order to accommodate domain sharding per XLA device.\".format(nx, self.nx))\n        self.ny = ny\n        self.nz = nz\n\n        self.show_simulation_parameters()\n\n        # Store grid information\n        self.gridInfo = {\n            \"nx\": self.nx,\n            \"ny\": self.ny,\n            \"nz\": self.nz,\n            \"dim\": self.lattice.d,\n            \"lattice\": self.lattice\n        }\n\n        P = PartitionSpec\n\n        # Define the right permutation\n        self.rightPerm = [(i, (i + 1) % self.nDevices) for i in range(self.nDevices)]\n        # Define the left permutation\n        self.leftPerm = [((i + 1) % self.nDevices, i) for i in range(self.nDevices)]\n\n        # Set up the sharding and streaming for 2D and 3D simulations\n        if self.dim == 2:\n            self.devices = mesh_utils.create_device_mesh((self.nDevices, 1, 1))\n            self.mesh = Mesh(self.devices, axis_names=(\"x\", \"y\", \"value\"))\n            self.sharding = NamedSharding(self.mesh, P(\"x\", \"y\", \"value\"))\n\n            self.streaming = jit(shard_map(self.streaming_m, mesh=self.mesh,\n                                                      in_specs=P(\"x\", None, None), out_specs=P(\"x\", None, None), check_rep=False))\n\n        # Set up the sharding and streaming for 2D and 3D simulations\n        elif self.dim == 3:\n            self.devices = mesh_utils.create_device_mesh((self.nDevices, 1, 1, 1))\n            self.mesh = Mesh(self.devices, axis_names=(\"x\", \"y\", \"z\", \"value\"))\n            self.sharding = NamedSharding(self.mesh, P(\"x\", \"y\", \"z\", \"value\"))\n\n            self.streaming = jit(shard_map(self.streaming_m, mesh=self.mesh,\n                                                      in_specs=P(\"x\", None, None, None), out_specs=P(\"x\", None, None, None), check_rep=False))\n\n        else:\n            raise ValueError(f\"dim = {self.dim} not supported\")\n\n        # Compute the bounding box indices for boundary conditions\n        self.boundingBoxIndices= self.bounding_box_indices()\n        # Create boundary data for the simulation\n        self._create_boundary_data()\n        self.force = self.get_force()\n\n    @property\n    def lattice(self):\n        return self._lattice\n\n    @lattice.setter\n    def lattice(self, value):\n        if value is None:\n            raise ValueError(\"Lattice type must be provided.\")\n        if self.nz == 0 and value.name not in ['D2Q9']:\n            raise ValueError(\"For 2D simulations, lattice type must be LatticeD2Q9.\")\n        if self.nz != 0 and value.name not in ['D3Q19', 'D3Q27']:\n            raise ValueError(\"For 3D simulations, lattice type must be LatticeD3Q19, or LatticeD3Q27.\")\n\n        self._lattice = value\n\n    @property\n    def omega(self):\n        return self._omega\n\n    @omega.setter\n    def omega(self, value):\n        if value is None:\n            raise ValueError(\"omega must be provided\")\n        if not isinstance(value, float):\n            raise TypeError(\"omega must be a float\")\n        self._omega = value\n\n    @property\n    def nx(self):\n        return self._nx\n\n    @nx.setter\n    def nx(self, value):\n        if value is None:\n            raise ValueError(\"nx must be provided\")\n        if not isinstance(value, int):\n            raise TypeError(\"nx must be an integer\")\n        self._nx = value\n\n    @property\n    def ny(self):\n        return self._ny\n\n    @ny.setter\n    def ny(self, value):\n        if value is None:\n            raise ValueError(\"ny must be provided\")\n        if not isinstance(value, int):\n            raise TypeError(\"ny must be an integer\")\n        self._ny = value\n\n    @property\n    def nz(self):\n        return self._nz\n\n    @nz.setter\n    def nz(self, value):\n        if value is None:\n            raise ValueError(\"nz must be provided\")\n        if not isinstance(value, int):\n            raise TypeError(\"nz must be an integer\")\n        self._nz = value\n\n    @property\n    def precision(self):\n        return self._precision\n\n    @precision.setter\n    def precision(self, value):\n        if not isinstance(value, str):\n            raise TypeError(\"precision must be a string\")\n        self._precision = value\n\n    @property\n    def checkpointRate(self):\n        return self._checkpointRate\n\n    @checkpointRate.setter\n    def checkpointRate(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"checkpointRate must be an integer\")\n        self._checkpointRate = value\n\n    @property\n    def checkpointDir(self):\n        return self._checkpointDir\n\n    @checkpointDir.setter\n    def checkpointDir(self, value):\n        if not isinstance(value, str):\n            raise TypeError(\"checkpointDir must be a string\")\n        self._checkpointDir = value\n\n    @property\n    def downsamplingFactor(self):\n        return self._downsamplingFactor\n\n    @downsamplingFactor.setter\n    def downsamplingFactor(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"downsamplingFactor must be an integer\")\n        self._downsamplingFactor = value\n\n    @property\n    def printInfoRate(self):\n        return self._printInfoRate\n\n    @printInfoRate.setter\n    def printInfoRate(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"printInfoRate must be an integer\")\n        self._printInfoRate = value\n\n    @property\n    def ioRate(self):\n        return self._ioRate\n\n    @ioRate.setter\n    def ioRate(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"ioRate must be an integer\")\n        self._ioRate = value\n\n    @property\n    def returnFpost(self):\n        return self._returnFpost\n\n    @returnFpost.setter\n    def returnFpost(self, value):\n        if not isinstance(value, bool):\n            raise TypeError(\"returnFpost must be a boolean\")\n        self._returnFpost = value\n\n    @property\n    def computeMLUPS(self):\n        return self._computeMLUPS\n\n    @computeMLUPS.setter\n    def computeMLUPS(self, value):\n        if not isinstance(value, bool):\n            raise TypeError(\"computeMLUPS must be a boolean\")\n        self._computeMLUPS = value\n\n    @property\n    def restore_checkpoint(self):\n        return self._restore_checkpoint\n\n    @restore_checkpoint.setter\n    def restore_checkpoint(self, value):\n        if not isinstance(value, bool):\n            raise TypeError(\"restore_checkpoint must be a boolean\")\n        self._restore_checkpoint = value\n\n    @property\n    def nDevices(self):\n        return self._nDevices\n\n    @nDevices.setter\n    def nDevices(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"nDevices must be an integer\")\n        self._nDevices = value\n\n    def show_simulation_parameters(self):\n        attributes_to_show = [\n            'omega', 'nx', 'ny', 'nz', 'dim', 'precision', 'lattice', \n            'checkpointRate', 'checkpointDir', 'downsamplingFactor', \n            'printInfoRate', 'ioRate', 'computeMLUPS', \n            'restore_checkpoint', 'backend', 'nDevices'\n        ]\n\n        descriptive_names = {\n            'omega': 'Omega',\n            'nx': 'Grid Points in X',\n            'ny': 'Grid Points in Y',\n            'nz': 'Grid Points in Z',\n            'dim': 'Dimensionality',\n            'precision': 'Precision Policy',\n            'lattice': 'Lattice Type',\n            'checkpointRate': 'Checkpoint Rate',\n            'checkpointDir': 'Checkpoint Directory',\n            'downsamplingFactor': 'Downsampling Factor',\n            'printInfoRate': 'Print Info Rate',\n            'ioRate': 'I/O Rate',\n            'computeMLUPS': 'Compute MLUPS',\n            'restore_checkpoint': 'Restore Checkpoint',\n            'backend': 'Backend',\n            'nDevices': 'Number of Devices'\n        }\n        simulation_name = self.__class__.__name__\n\n        print(colored(f'**** Simulation Parameters for {simulation_name} ****', 'green'))\n\n        header = f\"{colored('Parameter', 'blue'):&gt;30} | {colored('Value', 'yellow')}\"\n        print(header)\n        print('-' * 50)\n\n        for attr in attributes_to_show:\n            value = getattr(self, attr, 'Attribute not set')\n            descriptive_name = descriptive_names.get(attr, attr)  # Use the attribute name as a fallback\n            row = f\"{colored(descriptive_name, 'blue'):&gt;30} | {colored(value, 'yellow')}\"\n            print(row)\n\n    def _create_boundary_data(self):\n        \"\"\"\n        Create boundary data for the Lattice Boltzmann simulation by setting boundary conditions,\n        creating grid mask, and preparing local masks and normal arrays.\n        \"\"\"\n        self.BCs = []\n        self.set_boundary_conditions()\n        # Accumulate the indices of all BCs to create the grid mask with FALSE along directions that\n        # stream into a boundary voxel.\n        solid_halo_list = [np.array(bc.indices).T for bc in self.BCs if bc.isSolid]\n        solid_halo_voxels = np.unique(np.vstack(solid_halo_list), axis=0) if solid_halo_list else None\n\n        # Create the grid mask on each process\n        start = time.time()\n        grid_mask = self.create_grid_mask(solid_halo_voxels)\n        print(\"Time to create the grid mask:\", time.time() - start)\n\n        start = time.time()\n        for bc in self.BCs:\n            assert bc.implementationStep in ['PostStreaming', 'PostCollision']\n            bc.create_local_mask_and_normal_arrays(grid_mask)\n        print(\"Time to create the local masks and normal arrays:\", time.time() - start)\n\n    # This is another non-JITed way of creating the distributed arrays. It is not used at the moment.\n    # def distributed_array_init(self, shape, type, init_val=None):\n    #     sharding_dim = shape[0] // self.nDevices\n    #     sharded_shape = (self.nDevices, sharding_dim,  *shape[1:])\n    #     device_shape = sharded_shape[1:]\n    #     arrays = []\n\n    #     for d, index in self.sharding.addressable_devices_indices_map(sharded_shape).items():\n    #         jax.default_device = d\n    #         if init_val is None:\n    #             x = jnp.zeros(shape=device_shape, dtype=type)\n    #         else:\n    #             x = jnp.full(shape=device_shape, fill_value=init_val, dtype=type)  \n    #         arrays += [jax.device_put(x, d)] \n    #     jax.default_device = jax.devices()[0]\n    #     return jax.make_array_from_single_device_arrays(shape, self.sharding, arrays)\n\n    @partial(jit, static_argnums=(0, 1, 2, 4))\n    def distributed_array_init(self, shape, type, init_val=0, sharding=None):\n        \"\"\"\n        Initialize a distributed array using JAX, with a specified shape, data type, and initial value.\n        Optionally, provide a custom sharding strategy.\n\n        Parameters\n        ----------\n            shape (tuple): The shape of the array to be created.\n            type (dtype): The data type of the array to be created.\n            init_val (scalar, optional): The initial value to fill the array with. Defaults to 0.\n            sharding (Sharding, optional): The sharding strategy to use. Defaults to `self.sharding`.\n\n        Returns\n        -------\n            jax.numpy.ndarray: A JAX array with the specified shape, data type, initial value, and sharding strategy.\n        \"\"\"\n        if sharding is None:\n            sharding = self.sharding\n        x = jnp.full(shape=shape, fill_value=init_val, dtype=type)        \n        return jax.lax.with_sharding_constraint(x, sharding)\n\n    @partial(jit, static_argnums=(0,))\n    def create_grid_mask(self, solid_halo_voxels):\n        \"\"\"\n        This function creates a mask for the background grid that accounts for the location of the boundaries.\n\n        Parameters\n        ----------\n            solid_halo_voxels: A numpy array representing the voxels in the halo of the solid object.\n\n        Returns\n        -------\n            A JAX array representing the grid mask of the grid.\n        \"\"\"\n        # Halo width (hw_x is different to accommodate the domain sharding per XLA device)\n        hw_x = self.nDevices\n        hw_y = hw_z = 1\n        if self.dim == 2:\n            grid_mask = self.distributed_array_init((self.nx + 2 * hw_x, self.ny + 2 * hw_y, self.lattice.q), jnp.bool_, init_val=True)\n            grid_mask = grid_mask.at[(slice(hw_x, -hw_x), slice(hw_y, -hw_y), slice(None))].set(False)\n            if solid_halo_voxels is not None:\n                solid_halo_voxels = solid_halo_voxels.at[:, 0].add(hw_x)\n                solid_halo_voxels = solid_halo_voxels.at[:, 1].add(hw_y)\n                grid_mask = grid_mask.at[tuple(solid_halo_voxels.T)].set(True)  \n\n            grid_mask = self.streaming(grid_mask)\n            return lax.with_sharding_constraint(grid_mask, self.sharding)\n\n        elif self.dim == 3:\n            grid_mask = self.distributed_array_init((self.nx + 2 * hw_x, self.ny + 2 * hw_y, self.nz + 2 * hw_z, self.lattice.q), jnp.bool_, init_val=True)\n            grid_mask = grid_mask.at[(slice(hw_x, -hw_x), slice(hw_y, -hw_y), slice(hw_z, -hw_z), slice(None))].set(False)\n            if solid_halo_voxels is not None:\n                solid_halo_voxels = solid_halo_voxels.at[:, 0].add(hw_x)\n                solid_halo_voxels = solid_halo_voxels.at[:, 1].add(hw_y)\n                solid_halo_voxels = solid_halo_voxels.at[:, 2].add(hw_z)\n                grid_mask = grid_mask.at[tuple(solid_halo_voxels.T)].set(True)\n            grid_mask = self.streaming(grid_mask)\n            return lax.with_sharding_constraint(grid_mask, self.sharding)\n\n    def bounding_box_indices(self):\n        \"\"\"\n        This function calculates the indices of the bounding box of a 2D or 3D grid.\n        The bounding box is defined as the set of grid points on the outer edge of the grid.\n\n        Returns\n        -------\n            boundingBox (dict): A dictionary where keys are the names of the bounding box faces\n            (\"bottom\", \"top\", \"left\", \"right\" for 2D; additional \"front\", \"back\" for 3D), and values\n            are numpy arrays of indices corresponding to each face.\n        \"\"\"\n        if self.dim == 2:\n            # For a 2D grid, the bounding box consists of four edges: bottom, top, left, and right.\n            # Each edge is represented as an array of indices. For example, the bottom edge includes\n            # all points where the y-coordinate is 0, so its indices are [[i, 0] for i in range(self.nx)].\n            bounding_box = {\"bottom\": np.array([[i, 0] for i in range(self.nx)], dtype=int),\n                           \"top\": np.array([[i, self.ny - 1] for i in range(self.nx)], dtype=int),\n                           \"left\": np.array([[0, i] for i in range(self.ny)], dtype=int),\n                           \"right\": np.array([[self.nx - 1, i] for i in range(self.ny)], dtype=int)}\n\n            return bounding_box\n\n        elif self.dim == 3:\n            # For a 3D grid, the bounding box consists of six faces: bottom, top, left, right, front, and back.\n            # Each face is represented as an array of indices. For example, the bottom face includes all points\n            # where the z-coordinate is 0, so its indices are [[i, j, 0] for i in range(self.nx) for j in range(self.ny)].\n            bounding_box = {\n                \"bottom\": np.array([[i, j, 0] for i in range(self.nx) for j in range(self.ny)], dtype=int),\n                \"top\": np.array([[i, j, self.nz - 1] for i in range(self.nx) for j in range(self.ny)],dtype=int),\n                \"left\": np.array([[0, j, k] for j in range(self.ny) for k in range(self.nz)], dtype=int),\n                \"right\": np.array([[self.nx - 1, j, k] for j in range(self.ny) for k in range(self.nz)], dtype=int),\n                \"front\": np.array([[i, 0, k] for i in range(self.nx) for k in range(self.nz)], dtype=int),\n                \"back\": np.array([[i, self.ny - 1, k] for i in range(self.nx) for k in range(self.nz)], dtype=int)}\n\n            return bounding_box\n\n    def set_precisions(self, precision):\n        \"\"\"\n        This function sets the precision of the computations. The precision is defined by a pair of values,\n        representing the precision of the computation and the precision of the storage, respectively.\n\n        Parameters\n        ----------\n            precision (str): A string representing the desired precision. The string should be in the format\n            \"computation/storage\", where \"computation\" and \"storage\" are either \"f64\", \"f32\", or \"f16\",\n            representing 64-bit, 32-bit, or 16-bit floating point numbers, respectively.\n\n        Returns\n        -------\n            tuple: A pair of jax.numpy data types representing the computation and storage precisions, respectively.\n            If the input string does not match any of the predefined options, the function defaults to (jnp.float32, jnp.float32).\n        \"\"\"\n        return {\n            \"f64/f64\": (jnp.float64, jnp.float64),\n            \"f32/f32\": (jnp.float32, jnp.float32),\n            \"f32/f16\": (jnp.float32, jnp.float16),\n            \"f16/f16\": (jnp.float16, jnp.float16),\n            \"f64/f32\": (jnp.float64, jnp.float32),\n            \"f64/f16\": (jnp.float64, jnp.float16),\n        }.get(precision, (jnp.float32, jnp.float32))\n\n    def initialize_macroscopic_fields(self):\n        \"\"\"\n        This function initializes the macroscopic fields (density and velocity) to their default values.\n        The default density is 1 and the default velocity is 0.\n\n        Note: This function is a placeholder and should be overridden in a subclass or in an instance of the class\n        to provide specific initial conditions.\n\n        Returns\n        -------\n            None, None: The default density and velocity, both None. This indicates that the actual values should be set elsewhere.\n        \"\"\"\n        print(\"WARNING: Default initial conditions assumed: density = 1, velocity = 0\")\n        print(\"         To set explicit initial density and velocity, use self.initialize_macroscopic_fields.\")\n        return None, None\n\n    def assign_fields_sharded(self):\n        \"\"\"\n        This function is used to initialize the simulation by assigning the macroscopic fields and populations.\n\n        The function first initializes the macroscopic fields, which are the density (rho0) and velocity (u0).\n        Depending on the dimension of the simulation (2D or 3D), it then sets the shape of the array that will hold the \n        distribution functions (f).\n\n        If the density or velocity are not provided, the function initializes the distribution functions with a default \n        value (self.w), representing density=1 and velocity=0. Otherwise, it uses the provided density and velocity to initialize the populations.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        f: a distributed JAX array of shape (nx, ny, nz, q) or (nx, ny, q) holding the distribution functions for the simulation.\n        \"\"\"\n        rho0, u0 = self.initialize_macroscopic_fields()\n\n        if self.dim == 2:\n            shape = (self.nx, self.ny, self.lattice.q)\n        if self.dim == 3:\n            shape = (self.nx, self.ny, self.nz, self.lattice.q)\n\n        if rho0 is None or u0 is None:\n            f = self.distributed_array_init(shape, self.precisionPolicy.output_dtype, init_val=self.w)\n        else:\n            f = self.initialize_populations(rho0, u0)\n\n        return f\n\n    def initialize_populations(self, rho0, u0):\n        \"\"\"\n        This function initializes the populations (distribution functions) for the simulation.\n        It uses the equilibrium distribution function, which is a function of the macroscopic \n        density and velocity.\n\n        Parameters\n        ----------\n        rho0: jax.numpy.ndarray\n            The initial density field.\n        u0: jax.numpy.ndarray\n            The initial velocity field.\n\n        Returns\n        -------\n        f: jax.numpy.ndarray\n            The array holding the initialized distribution functions for the simulation.\n        \"\"\"\n        return self.equilibrium(rho0, u0)\n\n    def send_right(self, x, axis_name):\n        \"\"\"\n        This function sends the data to the right neighboring process in a parallel computing environment.\n        It uses a permutation operation provided by the LAX library.\n\n        Parameters\n        ----------\n        x: jax.numpy.ndarray\n            The data to be sent.\n        axis_name: str\n            The name of the axis along which the data is sent.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The data after being sent to the right neighboring process.\n        \"\"\"\n        return lax.ppermute(x, perm=self.rightPerm, axis_name=axis_name)\n\n    def send_left(self, x, axis_name):\n        \"\"\"\n        This function sends the data to the left neighboring process in a parallel computing environment.\n        It uses a permutation operation provided by the LAX library.\n\n        Parameters\n        ----------\n        x: jax.numpy.ndarray\n            The data to be sent.\n        axis_name: str\n            The name of the axis along which the data is sent.\n\n        Returns\n        -------\n            The data after being sent to the left neighboring process.\n        \"\"\"\n        return lax.ppermute(x, perm=self.leftPerm, axis_name=axis_name)\n\n    def streaming_m(self, f):\n        \"\"\"\n        This function performs the streaming step in the Lattice Boltzmann Method, which is \n        the propagation of the distribution functions in the lattice.\n\n        To enable multi-GPU/TPU functionality, it extracts the left and right boundary slices of the\n        distribution functions that need to be communicated to the neighboring processes.\n\n        The function then sends the left boundary slice to the right neighboring process and the right \n        boundary slice to the left neighboring process. The received data is then set to the \n        corresponding indices in the receiving domain.\n\n        Parameters\n        ----------\n        f: jax.numpy.ndarray\n            The array holding the distribution functions for the simulation.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The distribution functions after the streaming operation.\n        \"\"\"\n        f = self.streaming_p(f)\n        left_comm, right_comm = f[:1, ..., self.lattice.right_indices], f[-1:, ..., self.lattice.left_indices]\n\n        left_comm, right_comm = self.send_right(left_comm, 'x'), self.send_left(right_comm, 'x')\n        f = f.at[:1, ..., self.lattice.right_indices].set(left_comm)\n        f = f.at[-1:, ..., self.lattice.left_indices].set(right_comm)\n        return f\n\n    @partial(jit, static_argnums=(0,))\n    def streaming_p(self, f):\n        \"\"\"\n        Perform streaming operation on a partitioned (in the x-direction) distribution function.\n\n        The function uses the vmap operation provided by the JAX library to vectorize the computation \n        over all lattice directions.\n\n        Parameters\n        ----------\n            f: The distribution function.\n\n        Returns\n        -------\n            The updated distribution function after streaming.\n        \"\"\"\n        def streaming_i(f, c):\n            \"\"\"\n            Perform individual streaming operation in a direction.\n\n            Parameters\n            ----------\n                f: The distribution function.\n                c: The streaming direction vector.\n\n            Returns\n            -------\n                jax.numpy.ndarray\n                The updated distribution function after streaming.\n            \"\"\"\n            if self.dim == 2:\n                return jnp.roll(f, (c[0], c[1]), axis=(0, 1))\n            elif self.dim == 3:\n                return jnp.roll(f, (c[0], c[1], c[2]), axis=(0, 1, 2))\n\n        return vmap(streaming_i, in_axes=(-1, 0), out_axes=-1)(f, self.c.T)\n\n    @partial(jit, static_argnums=(0, 3), inline=True)\n    def equilibrium(self, rho, u, cast_output=True):\n        \"\"\"\n        This function computes the equilibrium distribution function in the Lattice Boltzmann Method.\n        The equilibrium distribution function is a function of the macroscopic density and velocity.\n\n        The function first casts the density and velocity to the compute precision if the cast_output flag is True.\n        The function finally casts the equilibrium distribution function to the output precision if the cast_output \n        flag is True.\n\n        Parameters\n        ----------\n        rho: jax.numpy.ndarray\n            The macroscopic density.\n        u: jax.numpy.ndarray\n            The macroscopic velocity.\n        cast_output: bool, optional\n            A flag indicating whether to cast the density, velocity, and equilibrium distribution function to the \n            compute and output precisions. Default is True.\n\n        Returns\n        -------\n        feq: ja.numpy.ndarray\n            The equilibrium distribution function.\n        \"\"\"\n        # Cast the density and velocity to the compute precision if the cast_output flag is True\n        if cast_output:\n            rho, u = self.precisionPolicy.cast_to_compute((rho, u))\n\n        # Cast c to compute precision so that XLA call FXX matmul, \n        # which is faster (it is faster in some older versions of JAX, newer versions are smart enough to do this automatically)\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype)\n        # print(\"c shape \", c.shape)\n        # print(\"u shape \", u.shape)\n        cu = 3.0 * jnp.dot(u, c)\n        usqr = 1.5 * jnp.sum(jnp.square(u), axis=-1, keepdims=True)\n        feq = rho * self.w * (1.0 + cu * (1.0 + 0.5 * cu) - usqr)\n\n        if cast_output:\n            return self.precisionPolicy.cast_to_output(feq)\n        else:\n            return feq\n\n    @partial(jit, static_argnums=(0,))\n    def momentum_flux(self, fneq):\n        \"\"\"\n        This function computes the momentum flux, which is the product of the non-equilibrium \n        distribution functions (fneq) and the lattice moments (cc).\n\n        The momentum flux is used in the computation of the stress tensor in the Lattice Boltzmann \n        Method (LBM).\n\n        Parameters\n        ----------\n        fneq: jax.numpy.ndarray\n            The non-equilibrium distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The computed momentum flux.\n        \"\"\"\n        return jnp.dot(fneq, self.lattice.cc)\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def update_macroscopic(self, f):\n        \"\"\"\n        This function computes the macroscopic variables (density and velocity) based on the \n        distribution functions (f).\n\n        The density is computed as the sum of the distribution functions over all lattice directions. \n        The velocity is computed as the dot product of the distribution functions and the lattice \n        velocities, divided by the density.\n\n        Parameters\n        ----------\n        f: jax.numpy.ndarray\n            The distribution functions.\n\n        Returns\n        -------\n        rho: jax.numpy.ndarray\n            Computed density.\n        u: jax.numpy.ndarray\n            Computed velocity.\n        \"\"\"\n        rho =jnp.sum(f, axis=-1, keepdims=True)\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n        u = jnp.dot(f, c) / rho\n\n        return rho, u\n\n    @partial(jit, static_argnums=(0, 4), inline=True)\n    def apply_bc(self, fout, fin, timestep, implementation_step):\n        \"\"\"\n        This function applies the boundary conditions to the distribution functions.\n\n        It iterates over all boundary conditions (BCs) and checks if the implementation step of the \n        boundary condition matches the provided implementation step. If it does, it applies the \n        boundary condition to the post-streaming distribution functions (fout).\n\n        Parameters\n        ----------\n        fout: jax.numpy.ndarray\n            The post-collision distribution functions.\n        fin: jax.numpy.ndarray\n            The post-streaming distribution functions.\n        implementation_step: str\n            The implementation step at which the boundary conditions should be applied.\n\n        Returns\n        -------\n        ja.numpy.ndarray\n            The output distribution functions after applying the boundary conditions.\n        \"\"\"\n        for bc in self.BCs:\n            fout = bc.prepare_populations(fout, fin, implementation_step)\n            if bc.implementationStep == implementation_step:\n                if bc.isDynamic:\n                    fout = bc.apply(fout, fin, timestep)\n                else:\n                    fout = fout.at[bc.indices].set(bc.apply(fout, fin))\n\n        return fout\n\n    @partial(jit, static_argnums=(0, 3), donate_argnums=(1,))\n    def step(self, f_poststreaming, timestep, return_fpost=False):\n        \"\"\"\n        This function performs a single step of the LBM simulation.\n\n        It first performs the collision step, which is the relaxation of the distribution functions \n        towards their equilibrium values. It then applies the respective boundary conditions to the \n        post-collision distribution functions.\n\n        The function then performs the streaming step, which is the propagation of the distribution \n        functions in the lattice. It then applies the respective boundary conditions to the post-streaming \n        distribution functions.\n\n        Parameters\n        ----------\n        f_poststreaming: jax.numpy.ndarray\n            The post-streaming distribution functions.\n        timestep: int\n            The current timestep of the simulation.\n        return_fpost: bool, optional\n            If True, the function also returns the post-collision distribution functions.\n\n        Returns\n        -------\n        f_poststreaming: jax.numpy.ndarray\n            The post-streaming distribution functions after the simulation step.\n        f_postcollision: jax.numpy.ndarray or None\n            The post-collision distribution functions after the simulation step, or None if \n            return_fpost is False.\n        \"\"\"\n        f_postcollision = self.collision(f_poststreaming)\n        f_postcollision = self.apply_bc(f_postcollision, f_poststreaming, timestep, \"PostCollision\")\n        f_poststreaming = self.streaming(f_postcollision)\n        f_poststreaming = self.apply_bc(f_poststreaming, f_postcollision, timestep, \"PostStreaming\")\n\n        if return_fpost:\n            return f_poststreaming, f_postcollision\n        else:\n            return f_poststreaming, None\n\n    def run(self, t_max):\n        \"\"\"\n        This function runs the LBM simulation for a specified number of time steps.\n\n        It first initializes the distribution functions and then enters a loop where it performs the \n        simulation steps (collision, streaming, and boundary conditions) for each time step.\n\n        The function can also print the progress of the simulation, save the simulation data, and \n        compute the performance of the simulation in million lattice updates per second (MLUPS).\n\n        Parameters\n        ----------\n        t_max: int\n            The total number of time steps to run the simulation.\n        Returns\n        -------\n        f: jax.numpy.ndarray\n            The distribution functions after the simulation.\n        \"\"\"\n        f = self.assign_fields_sharded()\n        start_step = 0\n        if self.restore_checkpoint:\n            latest_step = self.mngr.latest_step()\n            if latest_step is not None:  # existing checkpoint present\n                # Assert that the checkpoint manager is not None\n                assert self.mngr is not None, \"Checkpoint manager does not exist.\"\n                state = {'f': f}\n                shardings = jax.tree_map(lambda x: x.sharding, state)\n                restore_args = orb.checkpoint_utils.construct_restore_args(state, shardings)\n                try:\n                    f = self.mngr.restore(latest_step, restore_kwargs={'restore_args': restore_args})['f']\n                    print(f\"Restored checkpoint at step {latest_step}.\")\n                except ValueError:\n                    raise ValueError(f\"Failed to restore checkpoint at step {latest_step}.\")\n\n                start_step = latest_step + 1\n                if not (t_max &gt; start_step):\n                    raise ValueError(f\"Simulation already exceeded maximum allowable steps (t_max = {t_max}). Consider increasing t_max.\")\n        if self.computeMLUPS:\n            start = time.time()\n        # Loop over all time steps\n        for timestep in range(start_step, t_max + 1):\n            io_flag = self.ioRate &gt; 0 and (timestep % self.ioRate == 0 or timestep == t_max)\n            print_iter_flag = self.printInfoRate&gt; 0 and timestep % self.printInfoRate== 0\n            checkpoint_flag = self.checkpointRate &gt; 0 and timestep % self.checkpointRate == 0\n\n            if io_flag:\n                # Update the macroscopic variables and save the previous values (for error computation)\n                rho_prev, u_prev = self.update_macroscopic(f)\n                rho_prev = downsample_field(rho_prev, self.downsamplingFactor)\n                u_prev = downsample_field(u_prev, self.downsamplingFactor)\n                # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n                rho_prev = process_allgather(rho_prev)\n                u_prev = process_allgather(u_prev)\n\n\n            # Perform one time-step (collision, streaming, and boundary conditions)\n            f, fstar = self.step(f, timestep, return_fpost=self.returnFpost)\n            # Print the progress of the simulation\n            if print_iter_flag:\n                print(colored(\"Timestep \", 'blue') + colored(f\"{timestep}\", 'green') + colored(\" of \", 'blue') + colored(f\"{t_max}\", 'green') + colored(\" completed\", 'blue'))\n\n            if io_flag:\n                # Save the simulation data\n                print(f\"Saving data at timestep {timestep}/{t_max}\")\n                rho, u = self.update_macroscopic(f)\n                rho = downsample_field(rho, self.downsamplingFactor)\n                u = downsample_field(u, self.downsamplingFactor)\n\n                # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n                rho = process_allgather(rho)\n                u = process_allgather(u)\n\n                # Save the data\n                self.handle_io_timestep(timestep, f, fstar, rho, u, rho_prev, u_prev)\n\n            if checkpoint_flag:\n                # Save the checkpoint\n                print(f\"Saving checkpoint at timestep {timestep}/{t_max}\")\n                state = {'f': f}\n                self.mngr.save(timestep, state)\n\n            # Start the timer for the MLUPS computation after the first timestep (to remove compilation overhead)\n            if self.computeMLUPS and timestep == 1:\n                jax.block_until_ready(f)\n                start = time.time()\n\n        if self.computeMLUPS:\n            # Compute and print the performance of the simulation in MLUPS\n            jax.block_until_ready(f)\n            end = time.time()\n            if self.dim == 2:\n                print(colored(\"Domain: \", 'blue') + colored(f\"{self.nx} x {self.ny}\", 'green') if self.dim == 2 else colored(f\"{self.nx} x {self.ny} x {self.nz}\", 'green'))\n                print(colored(\"Number of voxels: \", 'blue') + colored(f\"{self.nx * self.ny}\", 'green') if self.dim == 2 else colored(f\"{self.nx * self.ny * self.nz}\", 'green'))\n                print(colored(\"MLUPS: \", 'blue') + colored(f\"{self.nx * self.ny * t_max / (end - start) / 1e6}\", 'red'))\n\n            elif self.dim == 3:\n                print(colored(\"Domain: \", 'blue') + colored(f\"{self.nx} x {self.ny} x {self.nz}\", 'green'))\n                print(colored(\"Number of voxels: \", 'blue') + colored(f\"{self.nx * self.ny * self.nz}\", 'green'))\n                print(colored(\"MLUPS: \", 'blue') + colored(f\"{self.nx * self.ny * self.nz * t_max / (end - start) / 1e6}\", 'red'))\n\n        return f\n\n    def handle_io_timestep(self, timestep, f, fstar, rho, u, rho_prev, u_prev):\n        \"\"\"\n        This function handles the input/output (I/O) operations at each time step of the simulation.\n\n        It prepares the data to be saved and calls the output_data function, which can be overwritten \n        by the user to customize the I/O operations.\n\n        Parameters\n        ----------\n        timestep: int\n            The current time step of the simulation.\n        f: jax.numpy.ndarray\n            The post-streaming distribution functions at the current time step.\n        fstar: jax.numpy.ndarray\n            The post-collision distribution functions at the current time step.\n        rho: jax.numpy.ndarray\n            The density field at the current time step.\n        u: jax.numpy.ndarray\n            The velocity field at the current time step.\n        \"\"\"\n        kwargs = {\n            \"timestep\": timestep,\n            \"rho\": rho,\n            \"rho_prev\": rho_prev,\n            \"u\": u,\n            \"u_prev\": u_prev,\n            \"f_poststreaming\": f,\n            \"f_postcollision\": fstar\n        }\n        self.output_data(**kwargs)\n\n    def output_data(self, **kwargs):\n        \"\"\"\n        This function is intended to be overwritten by the user to customize the input/output (I/O) \n        operations of the simulation.\n\n        By default, it does nothing. When overwritten, it could save the simulation data to files, \n        display the simulation results in real time, send the data to another process for analysis, etc.\n\n        Parameters\n        ----------\n        **kwargs: dict\n            A dictionary containing the simulation data to be outputted. The keys are the names of the \n            data fields, and the values are the data fields themselves.\n        \"\"\"\n        pass\n\n    def set_boundary_conditions(self):\n        \"\"\"\n        This function sets the boundary conditions for the simulation.\n\n        It is intended to be overwritten by the user to specify the boundary conditions according to \n        the specific problem being solved.\n\n        By default, it does nothing. When overwritten, it could set periodic boundaries, no-slip \n        boundaries, inflow/outflow boundaries, etc.\n        \"\"\"\n        pass\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, fin):\n        \"\"\"\n        This function performs the collision step in the Lattice Boltzmann Method.\n\n        It is intended to be overwritten by the user to specify the collision operator according to \n        the specific LBM model being used.\n\n        By default, it does nothing. When overwritten, it could implement the BGK collision operator,\n        the MRT collision operator, etc.\n\n        Parameters\n        ----------\n        fin: jax.numpy.ndarray\n            The pre-collision distribution functions.\n\n        Returns\n        -------\n        fin: jax.numpy.ndarray\n            The post-collision distribution functions.\n        \"\"\"\n        pass\n\n    def get_force(self):\n        \"\"\"\n        This function computes the force to be applied to the fluid in the Lattice Boltzmann Method.\n\n        It is intended to be overwritten by the user to specify the force according to the specific \n        problem being solved.\n\n        By default, it does nothing and returns None. When overwritten, it could implement a constant \n        force term.\n\n        Returns\n        -------\n        force: jax.numpy.ndarray\n            The force to be applied to the fluid.\n        \"\"\"\n        pass\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def apply_force(self, f_postcollision, feq, rho, u):\n        \"\"\"\n        add force based on exact-difference method due to Kupershtokh\n\n        Parameters\n        ----------\n        f_postcollision: jax.numpy.ndarray\n            The post-collision distribution functions.\n        feq: jax.numpy.ndarray\n            The equilibrium distribution functions.\n        rho: jax.numpy.ndarray\n            The density field.\n\n        u: jax.numpy.ndarray\n            The velocity field.\n\n        Returns\n        -------\n        f_postcollision: jax.numpy.ndarray\n            The post-collision distribution functions with the force applied.\n\n        References\n        ----------\n        Kupershtokh, A. (2004). New method of incorporating a body force term into the lattice Boltzmann equation. In\n        Proceedings of the 5th International EHD Workshop (pp. 241-246). University of Poitiers, Poitiers, France.\n        Chikatamarla, S. S., &amp; Karlin, I. V. (2013). Entropic lattice Boltzmann method for turbulent flow simulations:\n        Boundary conditions. Physica A, 392, 1925-1930.\n        Kr\u00fcger, T., et al. (2017). The lattice Boltzmann method. Springer International Publishing, 10.978-3, 4-15.\n        \"\"\"\n        delta_u = self.get_force()\n        feq_force = self.equilibrium(rho, u + delta_u, cast_output=False)\n        f_postcollision = f_postcollision + feq_force - feq\n        return f_postcollision\n</code></pre>"},{"location":"base/#src.base.LBMBase.apply_bc","title":"apply_bc","text":"<pre><code>apply_bc(fout, fin, timestep, implementation_step)\n</code></pre> <p>This function applies the boundary conditions to the distribution functions.</p> <p>It iterates over all boundary conditions (BCs) and checks if the implementation step of the  boundary condition matches the provided implementation step. If it does, it applies the  boundary condition to the post-streaming distribution functions (fout).</p>"},{"location":"base/#src.base.LBMBase.apply_bc--parameters","title":"Parameters","text":"<p>fout: jax.numpy.ndarray     The post-collision distribution functions. fin: jax.numpy.ndarray     The post-streaming distribution functions. implementation_step: str     The implementation step at which the boundary conditions should be applied.</p>"},{"location":"base/#src.base.LBMBase.apply_bc--returns","title":"Returns","text":"<p>ja.numpy.ndarray     The output distribution functions after applying the boundary conditions.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0, 4), inline=True)\ndef apply_bc(self, fout, fin, timestep, implementation_step):\n    \"\"\"\n    This function applies the boundary conditions to the distribution functions.\n\n    It iterates over all boundary conditions (BCs) and checks if the implementation step of the \n    boundary condition matches the provided implementation step. If it does, it applies the \n    boundary condition to the post-streaming distribution functions (fout).\n\n    Parameters\n    ----------\n    fout: jax.numpy.ndarray\n        The post-collision distribution functions.\n    fin: jax.numpy.ndarray\n        The post-streaming distribution functions.\n    implementation_step: str\n        The implementation step at which the boundary conditions should be applied.\n\n    Returns\n    -------\n    ja.numpy.ndarray\n        The output distribution functions after applying the boundary conditions.\n    \"\"\"\n    for bc in self.BCs:\n        fout = bc.prepare_populations(fout, fin, implementation_step)\n        if bc.implementationStep == implementation_step:\n            if bc.isDynamic:\n                fout = bc.apply(fout, fin, timestep)\n            else:\n                fout = fout.at[bc.indices].set(bc.apply(fout, fin))\n\n    return fout\n</code></pre>"},{"location":"base/#src.base.LBMBase.apply_force","title":"apply_force","text":"<pre><code>apply_force(f_postcollision, feq, rho, u)\n</code></pre> <p>add force based on exact-difference method due to Kupershtokh</p>"},{"location":"base/#src.base.LBMBase.apply_force--parameters","title":"Parameters","text":"<p>f_postcollision: jax.numpy.ndarray     The post-collision distribution functions. feq: jax.numpy.ndarray     The equilibrium distribution functions. rho: jax.numpy.ndarray     The density field.</p> jax.numpy.ndarray <p>The velocity field.</p>"},{"location":"base/#src.base.LBMBase.apply_force--returns","title":"Returns","text":"<p>f_postcollision: jax.numpy.ndarray     The post-collision distribution functions with the force applied.</p>"},{"location":"base/#src.base.LBMBase.apply_force--references","title":"References","text":"<p>Kupershtokh, A. (2004). New method of incorporating a body force term into the lattice Boltzmann equation. In Proceedings of the 5th International EHD Workshop (pp. 241-246). University of Poitiers, Poitiers, France. Chikatamarla, S. S., &amp; Karlin, I. V. (2013). Entropic lattice Boltzmann method for turbulent flow simulations: Boundary conditions. Physica A, 392, 1925-1930. Kr\u00fcger, T., et al. (2017). The lattice Boltzmann method. Springer International Publishing, 10.978-3, 4-15.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef apply_force(self, f_postcollision, feq, rho, u):\n    \"\"\"\n    add force based on exact-difference method due to Kupershtokh\n\n    Parameters\n    ----------\n    f_postcollision: jax.numpy.ndarray\n        The post-collision distribution functions.\n    feq: jax.numpy.ndarray\n        The equilibrium distribution functions.\n    rho: jax.numpy.ndarray\n        The density field.\n\n    u: jax.numpy.ndarray\n        The velocity field.\n\n    Returns\n    -------\n    f_postcollision: jax.numpy.ndarray\n        The post-collision distribution functions with the force applied.\n\n    References\n    ----------\n    Kupershtokh, A. (2004). New method of incorporating a body force term into the lattice Boltzmann equation. In\n    Proceedings of the 5th International EHD Workshop (pp. 241-246). University of Poitiers, Poitiers, France.\n    Chikatamarla, S. S., &amp; Karlin, I. V. (2013). Entropic lattice Boltzmann method for turbulent flow simulations:\n    Boundary conditions. Physica A, 392, 1925-1930.\n    Kr\u00fcger, T., et al. (2017). The lattice Boltzmann method. Springer International Publishing, 10.978-3, 4-15.\n    \"\"\"\n    delta_u = self.get_force()\n    feq_force = self.equilibrium(rho, u + delta_u, cast_output=False)\n    f_postcollision = f_postcollision + feq_force - feq\n    return f_postcollision\n</code></pre>"},{"location":"base/#src.base.LBMBase.assign_fields_sharded","title":"assign_fields_sharded","text":"<pre><code>assign_fields_sharded()\n</code></pre> <p>This function is used to initialize the simulation by assigning the macroscopic fields and populations.</p> <p>The function first initializes the macroscopic fields, which are the density (rho0) and velocity (u0). Depending on the dimension of the simulation (2D or 3D), it then sets the shape of the array that will hold the  distribution functions (f).</p> <p>If the density or velocity are not provided, the function initializes the distribution functions with a default  value (self.w), representing density=1 and velocity=0. Otherwise, it uses the provided density and velocity to initialize the populations.</p>"},{"location":"base/#src.base.LBMBase.assign_fields_sharded--parameters","title":"Parameters","text":"<p>None</p>"},{"location":"base/#src.base.LBMBase.assign_fields_sharded--returns","title":"Returns","text":"<p>f: a distributed JAX array of shape (nx, ny, nz, q) or (nx, ny, q) holding the distribution functions for the simulation.</p> Source code in <code>src/base.py</code> <pre><code>def assign_fields_sharded(self):\n    \"\"\"\n    This function is used to initialize the simulation by assigning the macroscopic fields and populations.\n\n    The function first initializes the macroscopic fields, which are the density (rho0) and velocity (u0).\n    Depending on the dimension of the simulation (2D or 3D), it then sets the shape of the array that will hold the \n    distribution functions (f).\n\n    If the density or velocity are not provided, the function initializes the distribution functions with a default \n    value (self.w), representing density=1 and velocity=0. Otherwise, it uses the provided density and velocity to initialize the populations.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    f: a distributed JAX array of shape (nx, ny, nz, q) or (nx, ny, q) holding the distribution functions for the simulation.\n    \"\"\"\n    rho0, u0 = self.initialize_macroscopic_fields()\n\n    if self.dim == 2:\n        shape = (self.nx, self.ny, self.lattice.q)\n    if self.dim == 3:\n        shape = (self.nx, self.ny, self.nz, self.lattice.q)\n\n    if rho0 is None or u0 is None:\n        f = self.distributed_array_init(shape, self.precisionPolicy.output_dtype, init_val=self.w)\n    else:\n        f = self.initialize_populations(rho0, u0)\n\n    return f\n</code></pre>"},{"location":"base/#src.base.LBMBase.bounding_box_indices","title":"bounding_box_indices","text":"<pre><code>bounding_box_indices()\n</code></pre> <p>This function calculates the indices of the bounding box of a 2D or 3D grid. The bounding box is defined as the set of grid points on the outer edge of the grid.</p>"},{"location":"base/#src.base.LBMBase.bounding_box_indices--returns","title":"Returns","text":"<pre><code>boundingBox (dict): A dictionary where keys are the names of the bounding box faces\n(\"bottom\", \"top\", \"left\", \"right\" for 2D; additional \"front\", \"back\" for 3D), and values\nare numpy arrays of indices corresponding to each face.\n</code></pre> Source code in <code>src/base.py</code> <pre><code>def bounding_box_indices(self):\n    \"\"\"\n    This function calculates the indices of the bounding box of a 2D or 3D grid.\n    The bounding box is defined as the set of grid points on the outer edge of the grid.\n\n    Returns\n    -------\n        boundingBox (dict): A dictionary where keys are the names of the bounding box faces\n        (\"bottom\", \"top\", \"left\", \"right\" for 2D; additional \"front\", \"back\" for 3D), and values\n        are numpy arrays of indices corresponding to each face.\n    \"\"\"\n    if self.dim == 2:\n        # For a 2D grid, the bounding box consists of four edges: bottom, top, left, and right.\n        # Each edge is represented as an array of indices. For example, the bottom edge includes\n        # all points where the y-coordinate is 0, so its indices are [[i, 0] for i in range(self.nx)].\n        bounding_box = {\"bottom\": np.array([[i, 0] for i in range(self.nx)], dtype=int),\n                       \"top\": np.array([[i, self.ny - 1] for i in range(self.nx)], dtype=int),\n                       \"left\": np.array([[0, i] for i in range(self.ny)], dtype=int),\n                       \"right\": np.array([[self.nx - 1, i] for i in range(self.ny)], dtype=int)}\n\n        return bounding_box\n\n    elif self.dim == 3:\n        # For a 3D grid, the bounding box consists of six faces: bottom, top, left, right, front, and back.\n        # Each face is represented as an array of indices. For example, the bottom face includes all points\n        # where the z-coordinate is 0, so its indices are [[i, j, 0] for i in range(self.nx) for j in range(self.ny)].\n        bounding_box = {\n            \"bottom\": np.array([[i, j, 0] for i in range(self.nx) for j in range(self.ny)], dtype=int),\n            \"top\": np.array([[i, j, self.nz - 1] for i in range(self.nx) for j in range(self.ny)],dtype=int),\n            \"left\": np.array([[0, j, k] for j in range(self.ny) for k in range(self.nz)], dtype=int),\n            \"right\": np.array([[self.nx - 1, j, k] for j in range(self.ny) for k in range(self.nz)], dtype=int),\n            \"front\": np.array([[i, 0, k] for i in range(self.nx) for k in range(self.nz)], dtype=int),\n            \"back\": np.array([[i, self.ny - 1, k] for i in range(self.nx) for k in range(self.nz)], dtype=int)}\n\n        return bounding_box\n</code></pre>"},{"location":"base/#src.base.LBMBase.collision","title":"collision","text":"<pre><code>collision(fin)\n</code></pre> <p>This function performs the collision step in the Lattice Boltzmann Method.</p> <p>It is intended to be overwritten by the user to specify the collision operator according to  the specific LBM model being used.</p> <p>By default, it does nothing. When overwritten, it could implement the BGK collision operator, the MRT collision operator, etc.</p>"},{"location":"base/#src.base.LBMBase.collision--parameters","title":"Parameters","text":"<p>fin: jax.numpy.ndarray     The pre-collision distribution functions.</p>"},{"location":"base/#src.base.LBMBase.collision--returns","title":"Returns","text":"<p>fin: jax.numpy.ndarray     The post-collision distribution functions.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, fin):\n    \"\"\"\n    This function performs the collision step in the Lattice Boltzmann Method.\n\n    It is intended to be overwritten by the user to specify the collision operator according to \n    the specific LBM model being used.\n\n    By default, it does nothing. When overwritten, it could implement the BGK collision operator,\n    the MRT collision operator, etc.\n\n    Parameters\n    ----------\n    fin: jax.numpy.ndarray\n        The pre-collision distribution functions.\n\n    Returns\n    -------\n    fin: jax.numpy.ndarray\n        The post-collision distribution functions.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base/#src.base.LBMBase.create_grid_mask","title":"create_grid_mask","text":"<pre><code>create_grid_mask(solid_halo_voxels)\n</code></pre> <p>This function creates a mask for the background grid that accounts for the location of the boundaries.</p>"},{"location":"base/#src.base.LBMBase.create_grid_mask--parameters","title":"Parameters","text":"<pre><code>solid_halo_voxels: A numpy array representing the voxels in the halo of the solid object.\n</code></pre>"},{"location":"base/#src.base.LBMBase.create_grid_mask--returns","title":"Returns","text":"<pre><code>A JAX array representing the grid mask of the grid.\n</code></pre> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef create_grid_mask(self, solid_halo_voxels):\n    \"\"\"\n    This function creates a mask for the background grid that accounts for the location of the boundaries.\n\n    Parameters\n    ----------\n        solid_halo_voxels: A numpy array representing the voxels in the halo of the solid object.\n\n    Returns\n    -------\n        A JAX array representing the grid mask of the grid.\n    \"\"\"\n    # Halo width (hw_x is different to accommodate the domain sharding per XLA device)\n    hw_x = self.nDevices\n    hw_y = hw_z = 1\n    if self.dim == 2:\n        grid_mask = self.distributed_array_init((self.nx + 2 * hw_x, self.ny + 2 * hw_y, self.lattice.q), jnp.bool_, init_val=True)\n        grid_mask = grid_mask.at[(slice(hw_x, -hw_x), slice(hw_y, -hw_y), slice(None))].set(False)\n        if solid_halo_voxels is not None:\n            solid_halo_voxels = solid_halo_voxels.at[:, 0].add(hw_x)\n            solid_halo_voxels = solid_halo_voxels.at[:, 1].add(hw_y)\n            grid_mask = grid_mask.at[tuple(solid_halo_voxels.T)].set(True)  \n\n        grid_mask = self.streaming(grid_mask)\n        return lax.with_sharding_constraint(grid_mask, self.sharding)\n\n    elif self.dim == 3:\n        grid_mask = self.distributed_array_init((self.nx + 2 * hw_x, self.ny + 2 * hw_y, self.nz + 2 * hw_z, self.lattice.q), jnp.bool_, init_val=True)\n        grid_mask = grid_mask.at[(slice(hw_x, -hw_x), slice(hw_y, -hw_y), slice(hw_z, -hw_z), slice(None))].set(False)\n        if solid_halo_voxels is not None:\n            solid_halo_voxels = solid_halo_voxels.at[:, 0].add(hw_x)\n            solid_halo_voxels = solid_halo_voxels.at[:, 1].add(hw_y)\n            solid_halo_voxels = solid_halo_voxels.at[:, 2].add(hw_z)\n            grid_mask = grid_mask.at[tuple(solid_halo_voxels.T)].set(True)\n        grid_mask = self.streaming(grid_mask)\n        return lax.with_sharding_constraint(grid_mask, self.sharding)\n</code></pre>"},{"location":"base/#src.base.LBMBase.distributed_array_init","title":"distributed_array_init","text":"<pre><code>distributed_array_init(shape, type, init_val=0, sharding=None)\n</code></pre> <p>Initialize a distributed array using JAX, with a specified shape, data type, and initial value. Optionally, provide a custom sharding strategy.</p>"},{"location":"base/#src.base.LBMBase.distributed_array_init--parameters","title":"Parameters","text":"<pre><code>shape (tuple): The shape of the array to be created.\ntype (dtype): The data type of the array to be created.\ninit_val (scalar, optional): The initial value to fill the array with. Defaults to 0.\nsharding (Sharding, optional): The sharding strategy to use. Defaults to `self.sharding`.\n</code></pre>"},{"location":"base/#src.base.LBMBase.distributed_array_init--returns","title":"Returns","text":"<pre><code>jax.numpy.ndarray: A JAX array with the specified shape, data type, initial value, and sharding strategy.\n</code></pre> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0, 1, 2, 4))\ndef distributed_array_init(self, shape, type, init_val=0, sharding=None):\n    \"\"\"\n    Initialize a distributed array using JAX, with a specified shape, data type, and initial value.\n    Optionally, provide a custom sharding strategy.\n\n    Parameters\n    ----------\n        shape (tuple): The shape of the array to be created.\n        type (dtype): The data type of the array to be created.\n        init_val (scalar, optional): The initial value to fill the array with. Defaults to 0.\n        sharding (Sharding, optional): The sharding strategy to use. Defaults to `self.sharding`.\n\n    Returns\n    -------\n        jax.numpy.ndarray: A JAX array with the specified shape, data type, initial value, and sharding strategy.\n    \"\"\"\n    if sharding is None:\n        sharding = self.sharding\n    x = jnp.full(shape=shape, fill_value=init_val, dtype=type)        \n    return jax.lax.with_sharding_constraint(x, sharding)\n</code></pre>"},{"location":"base/#src.base.LBMBase.equilibrium","title":"equilibrium","text":"<pre><code>equilibrium(rho, u, cast_output=True)\n</code></pre> <p>This function computes the equilibrium distribution function in the Lattice Boltzmann Method. The equilibrium distribution function is a function of the macroscopic density and velocity.</p> <p>The function first casts the density and velocity to the compute precision if the cast_output flag is True. The function finally casts the equilibrium distribution function to the output precision if the cast_output  flag is True.</p>"},{"location":"base/#src.base.LBMBase.equilibrium--parameters","title":"Parameters","text":"<p>rho: jax.numpy.ndarray     The macroscopic density. u: jax.numpy.ndarray     The macroscopic velocity. cast_output: bool, optional     A flag indicating whether to cast the density, velocity, and equilibrium distribution function to the      compute and output precisions. Default is True.</p>"},{"location":"base/#src.base.LBMBase.equilibrium--returns","title":"Returns","text":"<p>feq: ja.numpy.ndarray     The equilibrium distribution function.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), inline=True)\ndef equilibrium(self, rho, u, cast_output=True):\n    \"\"\"\n    This function computes the equilibrium distribution function in the Lattice Boltzmann Method.\n    The equilibrium distribution function is a function of the macroscopic density and velocity.\n\n    The function first casts the density and velocity to the compute precision if the cast_output flag is True.\n    The function finally casts the equilibrium distribution function to the output precision if the cast_output \n    flag is True.\n\n    Parameters\n    ----------\n    rho: jax.numpy.ndarray\n        The macroscopic density.\n    u: jax.numpy.ndarray\n        The macroscopic velocity.\n    cast_output: bool, optional\n        A flag indicating whether to cast the density, velocity, and equilibrium distribution function to the \n        compute and output precisions. Default is True.\n\n    Returns\n    -------\n    feq: ja.numpy.ndarray\n        The equilibrium distribution function.\n    \"\"\"\n    # Cast the density and velocity to the compute precision if the cast_output flag is True\n    if cast_output:\n        rho, u = self.precisionPolicy.cast_to_compute((rho, u))\n\n    # Cast c to compute precision so that XLA call FXX matmul, \n    # which is faster (it is faster in some older versions of JAX, newer versions are smart enough to do this automatically)\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype)\n    # print(\"c shape \", c.shape)\n    # print(\"u shape \", u.shape)\n    cu = 3.0 * jnp.dot(u, c)\n    usqr = 1.5 * jnp.sum(jnp.square(u), axis=-1, keepdims=True)\n    feq = rho * self.w * (1.0 + cu * (1.0 + 0.5 * cu) - usqr)\n\n    if cast_output:\n        return self.precisionPolicy.cast_to_output(feq)\n    else:\n        return feq\n</code></pre>"},{"location":"base/#src.base.LBMBase.get_force","title":"get_force","text":"<pre><code>get_force()\n</code></pre> <p>This function computes the force to be applied to the fluid in the Lattice Boltzmann Method.</p> <p>It is intended to be overwritten by the user to specify the force according to the specific  problem being solved.</p> <p>By default, it does nothing and returns None. When overwritten, it could implement a constant  force term.</p>"},{"location":"base/#src.base.LBMBase.get_force--returns","title":"Returns","text":"<p>force: jax.numpy.ndarray     The force to be applied to the fluid.</p> Source code in <code>src/base.py</code> <pre><code>def get_force(self):\n    \"\"\"\n    This function computes the force to be applied to the fluid in the Lattice Boltzmann Method.\n\n    It is intended to be overwritten by the user to specify the force according to the specific \n    problem being solved.\n\n    By default, it does nothing and returns None. When overwritten, it could implement a constant \n    force term.\n\n    Returns\n    -------\n    force: jax.numpy.ndarray\n        The force to be applied to the fluid.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base/#src.base.LBMBase.handle_io_timestep","title":"handle_io_timestep","text":"<pre><code>handle_io_timestep(timestep, f, fstar, rho, u, rho_prev, u_prev)\n</code></pre> <p>This function handles the input/output (I/O) operations at each time step of the simulation.</p> <p>It prepares the data to be saved and calls the output_data function, which can be overwritten  by the user to customize the I/O operations.</p>"},{"location":"base/#src.base.LBMBase.handle_io_timestep--parameters","title":"Parameters","text":"<p>timestep: int     The current time step of the simulation. f: jax.numpy.ndarray     The post-streaming distribution functions at the current time step. fstar: jax.numpy.ndarray     The post-collision distribution functions at the current time step. rho: jax.numpy.ndarray     The density field at the current time step. u: jax.numpy.ndarray     The velocity field at the current time step.</p> Source code in <code>src/base.py</code> <pre><code>def handle_io_timestep(self, timestep, f, fstar, rho, u, rho_prev, u_prev):\n    \"\"\"\n    This function handles the input/output (I/O) operations at each time step of the simulation.\n\n    It prepares the data to be saved and calls the output_data function, which can be overwritten \n    by the user to customize the I/O operations.\n\n    Parameters\n    ----------\n    timestep: int\n        The current time step of the simulation.\n    f: jax.numpy.ndarray\n        The post-streaming distribution functions at the current time step.\n    fstar: jax.numpy.ndarray\n        The post-collision distribution functions at the current time step.\n    rho: jax.numpy.ndarray\n        The density field at the current time step.\n    u: jax.numpy.ndarray\n        The velocity field at the current time step.\n    \"\"\"\n    kwargs = {\n        \"timestep\": timestep,\n        \"rho\": rho,\n        \"rho_prev\": rho_prev,\n        \"u\": u,\n        \"u_prev\": u_prev,\n        \"f_poststreaming\": f,\n        \"f_postcollision\": fstar\n    }\n    self.output_data(**kwargs)\n</code></pre>"},{"location":"base/#src.base.LBMBase.initialize_macroscopic_fields","title":"initialize_macroscopic_fields","text":"<pre><code>initialize_macroscopic_fields()\n</code></pre> <p>This function initializes the macroscopic fields (density and velocity) to their default values. The default density is 1 and the default velocity is 0.</p> <p>Note: This function is a placeholder and should be overridden in a subclass or in an instance of the class to provide specific initial conditions.</p>"},{"location":"base/#src.base.LBMBase.initialize_macroscopic_fields--returns","title":"Returns","text":"<pre><code>None, None: The default density and velocity, both None. This indicates that the actual values should be set elsewhere.\n</code></pre> Source code in <code>src/base.py</code> <pre><code>def initialize_macroscopic_fields(self):\n    \"\"\"\n    This function initializes the macroscopic fields (density and velocity) to their default values.\n    The default density is 1 and the default velocity is 0.\n\n    Note: This function is a placeholder and should be overridden in a subclass or in an instance of the class\n    to provide specific initial conditions.\n\n    Returns\n    -------\n        None, None: The default density and velocity, both None. This indicates that the actual values should be set elsewhere.\n    \"\"\"\n    print(\"WARNING: Default initial conditions assumed: density = 1, velocity = 0\")\n    print(\"         To set explicit initial density and velocity, use self.initialize_macroscopic_fields.\")\n    return None, None\n</code></pre>"},{"location":"base/#src.base.LBMBase.initialize_populations","title":"initialize_populations","text":"<pre><code>initialize_populations(rho0, u0)\n</code></pre> <p>This function initializes the populations (distribution functions) for the simulation. It uses the equilibrium distribution function, which is a function of the macroscopic  density and velocity.</p>"},{"location":"base/#src.base.LBMBase.initialize_populations--parameters","title":"Parameters","text":"<p>rho0: jax.numpy.ndarray     The initial density field. u0: jax.numpy.ndarray     The initial velocity field.</p>"},{"location":"base/#src.base.LBMBase.initialize_populations--returns","title":"Returns","text":"<p>f: jax.numpy.ndarray     The array holding the initialized distribution functions for the simulation.</p> Source code in <code>src/base.py</code> <pre><code>def initialize_populations(self, rho0, u0):\n    \"\"\"\n    This function initializes the populations (distribution functions) for the simulation.\n    It uses the equilibrium distribution function, which is a function of the macroscopic \n    density and velocity.\n\n    Parameters\n    ----------\n    rho0: jax.numpy.ndarray\n        The initial density field.\n    u0: jax.numpy.ndarray\n        The initial velocity field.\n\n    Returns\n    -------\n    f: jax.numpy.ndarray\n        The array holding the initialized distribution functions for the simulation.\n    \"\"\"\n    return self.equilibrium(rho0, u0)\n</code></pre>"},{"location":"base/#src.base.LBMBase.momentum_flux","title":"momentum_flux","text":"<pre><code>momentum_flux(fneq)\n</code></pre> <p>This function computes the momentum flux, which is the product of the non-equilibrium  distribution functions (fneq) and the lattice moments (cc).</p> <p>The momentum flux is used in the computation of the stress tensor in the Lattice Boltzmann  Method (LBM).</p>"},{"location":"base/#src.base.LBMBase.momentum_flux--parameters","title":"Parameters","text":"<p>fneq: jax.numpy.ndarray     The non-equilibrium distribution functions.</p>"},{"location":"base/#src.base.LBMBase.momentum_flux--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The computed momentum flux.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef momentum_flux(self, fneq):\n    \"\"\"\n    This function computes the momentum flux, which is the product of the non-equilibrium \n    distribution functions (fneq) and the lattice moments (cc).\n\n    The momentum flux is used in the computation of the stress tensor in the Lattice Boltzmann \n    Method (LBM).\n\n    Parameters\n    ----------\n    fneq: jax.numpy.ndarray\n        The non-equilibrium distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The computed momentum flux.\n    \"\"\"\n    return jnp.dot(fneq, self.lattice.cc)\n</code></pre>"},{"location":"base/#src.base.LBMBase.output_data","title":"output_data","text":"<pre><code>output_data(**kwargs)\n</code></pre> <p>This function is intended to be overwritten by the user to customize the input/output (I/O)  operations of the simulation.</p> <p>By default, it does nothing. When overwritten, it could save the simulation data to files,  display the simulation results in real time, send the data to another process for analysis, etc.</p>"},{"location":"base/#src.base.LBMBase.output_data--parameters","title":"Parameters","text":"<p>**kwargs: dict     A dictionary containing the simulation data to be outputted. The keys are the names of the      data fields, and the values are the data fields themselves.</p> Source code in <code>src/base.py</code> <pre><code>def output_data(self, **kwargs):\n    \"\"\"\n    This function is intended to be overwritten by the user to customize the input/output (I/O) \n    operations of the simulation.\n\n    By default, it does nothing. When overwritten, it could save the simulation data to files, \n    display the simulation results in real time, send the data to another process for analysis, etc.\n\n    Parameters\n    ----------\n    **kwargs: dict\n        A dictionary containing the simulation data to be outputted. The keys are the names of the \n        data fields, and the values are the data fields themselves.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base/#src.base.LBMBase.run","title":"run","text":"<pre><code>run(t_max)\n</code></pre> <p>This function runs the LBM simulation for a specified number of time steps.</p> <p>It first initializes the distribution functions and then enters a loop where it performs the  simulation steps (collision, streaming, and boundary conditions) for each time step.</p> <p>The function can also print the progress of the simulation, save the simulation data, and  compute the performance of the simulation in million lattice updates per second (MLUPS).</p>"},{"location":"base/#src.base.LBMBase.run--parameters","title":"Parameters","text":"<p>t_max: int     The total number of time steps to run the simulation. Returns</p> <p>f: jax.numpy.ndarray     The distribution functions after the simulation.</p> Source code in <code>src/base.py</code> <pre><code>def run(self, t_max):\n    \"\"\"\n    This function runs the LBM simulation for a specified number of time steps.\n\n    It first initializes the distribution functions and then enters a loop where it performs the \n    simulation steps (collision, streaming, and boundary conditions) for each time step.\n\n    The function can also print the progress of the simulation, save the simulation data, and \n    compute the performance of the simulation in million lattice updates per second (MLUPS).\n\n    Parameters\n    ----------\n    t_max: int\n        The total number of time steps to run the simulation.\n    Returns\n    -------\n    f: jax.numpy.ndarray\n        The distribution functions after the simulation.\n    \"\"\"\n    f = self.assign_fields_sharded()\n    start_step = 0\n    if self.restore_checkpoint:\n        latest_step = self.mngr.latest_step()\n        if latest_step is not None:  # existing checkpoint present\n            # Assert that the checkpoint manager is not None\n            assert self.mngr is not None, \"Checkpoint manager does not exist.\"\n            state = {'f': f}\n            shardings = jax.tree_map(lambda x: x.sharding, state)\n            restore_args = orb.checkpoint_utils.construct_restore_args(state, shardings)\n            try:\n                f = self.mngr.restore(latest_step, restore_kwargs={'restore_args': restore_args})['f']\n                print(f\"Restored checkpoint at step {latest_step}.\")\n            except ValueError:\n                raise ValueError(f\"Failed to restore checkpoint at step {latest_step}.\")\n\n            start_step = latest_step + 1\n            if not (t_max &gt; start_step):\n                raise ValueError(f\"Simulation already exceeded maximum allowable steps (t_max = {t_max}). Consider increasing t_max.\")\n    if self.computeMLUPS:\n        start = time.time()\n    # Loop over all time steps\n    for timestep in range(start_step, t_max + 1):\n        io_flag = self.ioRate &gt; 0 and (timestep % self.ioRate == 0 or timestep == t_max)\n        print_iter_flag = self.printInfoRate&gt; 0 and timestep % self.printInfoRate== 0\n        checkpoint_flag = self.checkpointRate &gt; 0 and timestep % self.checkpointRate == 0\n\n        if io_flag:\n            # Update the macroscopic variables and save the previous values (for error computation)\n            rho_prev, u_prev = self.update_macroscopic(f)\n            rho_prev = downsample_field(rho_prev, self.downsamplingFactor)\n            u_prev = downsample_field(u_prev, self.downsamplingFactor)\n            # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n            rho_prev = process_allgather(rho_prev)\n            u_prev = process_allgather(u_prev)\n\n\n        # Perform one time-step (collision, streaming, and boundary conditions)\n        f, fstar = self.step(f, timestep, return_fpost=self.returnFpost)\n        # Print the progress of the simulation\n        if print_iter_flag:\n            print(colored(\"Timestep \", 'blue') + colored(f\"{timestep}\", 'green') + colored(\" of \", 'blue') + colored(f\"{t_max}\", 'green') + colored(\" completed\", 'blue'))\n\n        if io_flag:\n            # Save the simulation data\n            print(f\"Saving data at timestep {timestep}/{t_max}\")\n            rho, u = self.update_macroscopic(f)\n            rho = downsample_field(rho, self.downsamplingFactor)\n            u = downsample_field(u, self.downsamplingFactor)\n\n            # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n            rho = process_allgather(rho)\n            u = process_allgather(u)\n\n            # Save the data\n            self.handle_io_timestep(timestep, f, fstar, rho, u, rho_prev, u_prev)\n\n        if checkpoint_flag:\n            # Save the checkpoint\n            print(f\"Saving checkpoint at timestep {timestep}/{t_max}\")\n            state = {'f': f}\n            self.mngr.save(timestep, state)\n\n        # Start the timer for the MLUPS computation after the first timestep (to remove compilation overhead)\n        if self.computeMLUPS and timestep == 1:\n            jax.block_until_ready(f)\n            start = time.time()\n\n    if self.computeMLUPS:\n        # Compute and print the performance of the simulation in MLUPS\n        jax.block_until_ready(f)\n        end = time.time()\n        if self.dim == 2:\n            print(colored(\"Domain: \", 'blue') + colored(f\"{self.nx} x {self.ny}\", 'green') if self.dim == 2 else colored(f\"{self.nx} x {self.ny} x {self.nz}\", 'green'))\n            print(colored(\"Number of voxels: \", 'blue') + colored(f\"{self.nx * self.ny}\", 'green') if self.dim == 2 else colored(f\"{self.nx * self.ny * self.nz}\", 'green'))\n            print(colored(\"MLUPS: \", 'blue') + colored(f\"{self.nx * self.ny * t_max / (end - start) / 1e6}\", 'red'))\n\n        elif self.dim == 3:\n            print(colored(\"Domain: \", 'blue') + colored(f\"{self.nx} x {self.ny} x {self.nz}\", 'green'))\n            print(colored(\"Number of voxels: \", 'blue') + colored(f\"{self.nx * self.ny * self.nz}\", 'green'))\n            print(colored(\"MLUPS: \", 'blue') + colored(f\"{self.nx * self.ny * self.nz * t_max / (end - start) / 1e6}\", 'red'))\n\n    return f\n</code></pre>"},{"location":"base/#src.base.LBMBase.send_left","title":"send_left","text":"<pre><code>send_left(x, axis_name)\n</code></pre> <p>This function sends the data to the left neighboring process in a parallel computing environment. It uses a permutation operation provided by the LAX library.</p>"},{"location":"base/#src.base.LBMBase.send_left--parameters","title":"Parameters","text":"<p>x: jax.numpy.ndarray     The data to be sent. axis_name: str     The name of the axis along which the data is sent.</p>"},{"location":"base/#src.base.LBMBase.send_left--returns","title":"Returns","text":"<pre><code>The data after being sent to the left neighboring process.\n</code></pre> Source code in <code>src/base.py</code> <pre><code>def send_left(self, x, axis_name):\n    \"\"\"\n    This function sends the data to the left neighboring process in a parallel computing environment.\n    It uses a permutation operation provided by the LAX library.\n\n    Parameters\n    ----------\n    x: jax.numpy.ndarray\n        The data to be sent.\n    axis_name: str\n        The name of the axis along which the data is sent.\n\n    Returns\n    -------\n        The data after being sent to the left neighboring process.\n    \"\"\"\n    return lax.ppermute(x, perm=self.leftPerm, axis_name=axis_name)\n</code></pre>"},{"location":"base/#src.base.LBMBase.send_right","title":"send_right","text":"<pre><code>send_right(x, axis_name)\n</code></pre> <p>This function sends the data to the right neighboring process in a parallel computing environment. It uses a permutation operation provided by the LAX library.</p>"},{"location":"base/#src.base.LBMBase.send_right--parameters","title":"Parameters","text":"<p>x: jax.numpy.ndarray     The data to be sent. axis_name: str     The name of the axis along which the data is sent.</p>"},{"location":"base/#src.base.LBMBase.send_right--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The data after being sent to the right neighboring process.</p> Source code in <code>src/base.py</code> <pre><code>def send_right(self, x, axis_name):\n    \"\"\"\n    This function sends the data to the right neighboring process in a parallel computing environment.\n    It uses a permutation operation provided by the LAX library.\n\n    Parameters\n    ----------\n    x: jax.numpy.ndarray\n        The data to be sent.\n    axis_name: str\n        The name of the axis along which the data is sent.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The data after being sent to the right neighboring process.\n    \"\"\"\n    return lax.ppermute(x, perm=self.rightPerm, axis_name=axis_name)\n</code></pre>"},{"location":"base/#src.base.LBMBase.set_boundary_conditions","title":"set_boundary_conditions","text":"<pre><code>set_boundary_conditions()\n</code></pre> <p>This function sets the boundary conditions for the simulation.</p> <p>It is intended to be overwritten by the user to specify the boundary conditions according to  the specific problem being solved.</p> <p>By default, it does nothing. When overwritten, it could set periodic boundaries, no-slip  boundaries, inflow/outflow boundaries, etc.</p> Source code in <code>src/base.py</code> <pre><code>def set_boundary_conditions(self):\n    \"\"\"\n    This function sets the boundary conditions for the simulation.\n\n    It is intended to be overwritten by the user to specify the boundary conditions according to \n    the specific problem being solved.\n\n    By default, it does nothing. When overwritten, it could set periodic boundaries, no-slip \n    boundaries, inflow/outflow boundaries, etc.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base/#src.base.LBMBase.set_precisions","title":"set_precisions","text":"<pre><code>set_precisions(precision)\n</code></pre> <p>This function sets the precision of the computations. The precision is defined by a pair of values, representing the precision of the computation and the precision of the storage, respectively.</p>"},{"location":"base/#src.base.LBMBase.set_precisions--parameters","title":"Parameters","text":"<pre><code>precision (str): A string representing the desired precision. The string should be in the format\n\"computation/storage\", where \"computation\" and \"storage\" are either \"f64\", \"f32\", or \"f16\",\nrepresenting 64-bit, 32-bit, or 16-bit floating point numbers, respectively.\n</code></pre>"},{"location":"base/#src.base.LBMBase.set_precisions--returns","title":"Returns","text":"<pre><code>tuple: A pair of jax.numpy data types representing the computation and storage precisions, respectively.\nIf the input string does not match any of the predefined options, the function defaults to (jnp.float32, jnp.float32).\n</code></pre> Source code in <code>src/base.py</code> <pre><code>def set_precisions(self, precision):\n    \"\"\"\n    This function sets the precision of the computations. The precision is defined by a pair of values,\n    representing the precision of the computation and the precision of the storage, respectively.\n\n    Parameters\n    ----------\n        precision (str): A string representing the desired precision. The string should be in the format\n        \"computation/storage\", where \"computation\" and \"storage\" are either \"f64\", \"f32\", or \"f16\",\n        representing 64-bit, 32-bit, or 16-bit floating point numbers, respectively.\n\n    Returns\n    -------\n        tuple: A pair of jax.numpy data types representing the computation and storage precisions, respectively.\n        If the input string does not match any of the predefined options, the function defaults to (jnp.float32, jnp.float32).\n    \"\"\"\n    return {\n        \"f64/f64\": (jnp.float64, jnp.float64),\n        \"f32/f32\": (jnp.float32, jnp.float32),\n        \"f32/f16\": (jnp.float32, jnp.float16),\n        \"f16/f16\": (jnp.float16, jnp.float16),\n        \"f64/f32\": (jnp.float64, jnp.float32),\n        \"f64/f16\": (jnp.float64, jnp.float16),\n    }.get(precision, (jnp.float32, jnp.float32))\n</code></pre>"},{"location":"base/#src.base.LBMBase.step","title":"step","text":"<pre><code>step(f_poststreaming, timestep, return_fpost=False)\n</code></pre> <p>This function performs a single step of the LBM simulation.</p> <p>It first performs the collision step, which is the relaxation of the distribution functions  towards their equilibrium values. It then applies the respective boundary conditions to the  post-collision distribution functions.</p> <p>The function then performs the streaming step, which is the propagation of the distribution  functions in the lattice. It then applies the respective boundary conditions to the post-streaming  distribution functions.</p>"},{"location":"base/#src.base.LBMBase.step--parameters","title":"Parameters","text":"<p>f_poststreaming: jax.numpy.ndarray     The post-streaming distribution functions. timestep: int     The current timestep of the simulation. return_fpost: bool, optional     If True, the function also returns the post-collision distribution functions.</p>"},{"location":"base/#src.base.LBMBase.step--returns","title":"Returns","text":"<p>f_poststreaming: jax.numpy.ndarray     The post-streaming distribution functions after the simulation step. f_postcollision: jax.numpy.ndarray or None     The post-collision distribution functions after the simulation step, or None if      return_fpost is False.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), donate_argnums=(1,))\ndef step(self, f_poststreaming, timestep, return_fpost=False):\n    \"\"\"\n    This function performs a single step of the LBM simulation.\n\n    It first performs the collision step, which is the relaxation of the distribution functions \n    towards their equilibrium values. It then applies the respective boundary conditions to the \n    post-collision distribution functions.\n\n    The function then performs the streaming step, which is the propagation of the distribution \n    functions in the lattice. It then applies the respective boundary conditions to the post-streaming \n    distribution functions.\n\n    Parameters\n    ----------\n    f_poststreaming: jax.numpy.ndarray\n        The post-streaming distribution functions.\n    timestep: int\n        The current timestep of the simulation.\n    return_fpost: bool, optional\n        If True, the function also returns the post-collision distribution functions.\n\n    Returns\n    -------\n    f_poststreaming: jax.numpy.ndarray\n        The post-streaming distribution functions after the simulation step.\n    f_postcollision: jax.numpy.ndarray or None\n        The post-collision distribution functions after the simulation step, or None if \n        return_fpost is False.\n    \"\"\"\n    f_postcollision = self.collision(f_poststreaming)\n    f_postcollision = self.apply_bc(f_postcollision, f_poststreaming, timestep, \"PostCollision\")\n    f_poststreaming = self.streaming(f_postcollision)\n    f_poststreaming = self.apply_bc(f_poststreaming, f_postcollision, timestep, \"PostStreaming\")\n\n    if return_fpost:\n        return f_poststreaming, f_postcollision\n    else:\n        return f_poststreaming, None\n</code></pre>"},{"location":"base/#src.base.LBMBase.streaming_m","title":"streaming_m","text":"<pre><code>streaming_m(f)\n</code></pre> <p>This function performs the streaming step in the Lattice Boltzmann Method, which is  the propagation of the distribution functions in the lattice.</p> <p>To enable multi-GPU/TPU functionality, it extracts the left and right boundary slices of the distribution functions that need to be communicated to the neighboring processes.</p> <p>The function then sends the left boundary slice to the right neighboring process and the right  boundary slice to the left neighboring process. The received data is then set to the  corresponding indices in the receiving domain.</p>"},{"location":"base/#src.base.LBMBase.streaming_m--parameters","title":"Parameters","text":"<p>f: jax.numpy.ndarray     The array holding the distribution functions for the simulation.</p>"},{"location":"base/#src.base.LBMBase.streaming_m--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The distribution functions after the streaming operation.</p> Source code in <code>src/base.py</code> <pre><code>def streaming_m(self, f):\n    \"\"\"\n    This function performs the streaming step in the Lattice Boltzmann Method, which is \n    the propagation of the distribution functions in the lattice.\n\n    To enable multi-GPU/TPU functionality, it extracts the left and right boundary slices of the\n    distribution functions that need to be communicated to the neighboring processes.\n\n    The function then sends the left boundary slice to the right neighboring process and the right \n    boundary slice to the left neighboring process. The received data is then set to the \n    corresponding indices in the receiving domain.\n\n    Parameters\n    ----------\n    f: jax.numpy.ndarray\n        The array holding the distribution functions for the simulation.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The distribution functions after the streaming operation.\n    \"\"\"\n    f = self.streaming_p(f)\n    left_comm, right_comm = f[:1, ..., self.lattice.right_indices], f[-1:, ..., self.lattice.left_indices]\n\n    left_comm, right_comm = self.send_right(left_comm, 'x'), self.send_left(right_comm, 'x')\n    f = f.at[:1, ..., self.lattice.right_indices].set(left_comm)\n    f = f.at[-1:, ..., self.lattice.left_indices].set(right_comm)\n    return f\n</code></pre>"},{"location":"base/#src.base.LBMBase.streaming_p","title":"streaming_p","text":"<pre><code>streaming_p(f)\n</code></pre> <p>Perform streaming operation on a partitioned (in the x-direction) distribution function.</p> <p>The function uses the vmap operation provided by the JAX library to vectorize the computation  over all lattice directions.</p>"},{"location":"base/#src.base.LBMBase.streaming_p--parameters","title":"Parameters","text":"<pre><code>f: The distribution function.\n</code></pre>"},{"location":"base/#src.base.LBMBase.streaming_p--returns","title":"Returns","text":"<pre><code>The updated distribution function after streaming.\n</code></pre> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef streaming_p(self, f):\n    \"\"\"\n    Perform streaming operation on a partitioned (in the x-direction) distribution function.\n\n    The function uses the vmap operation provided by the JAX library to vectorize the computation \n    over all lattice directions.\n\n    Parameters\n    ----------\n        f: The distribution function.\n\n    Returns\n    -------\n        The updated distribution function after streaming.\n    \"\"\"\n    def streaming_i(f, c):\n        \"\"\"\n        Perform individual streaming operation in a direction.\n\n        Parameters\n        ----------\n            f: The distribution function.\n            c: The streaming direction vector.\n\n        Returns\n        -------\n            jax.numpy.ndarray\n            The updated distribution function after streaming.\n        \"\"\"\n        if self.dim == 2:\n            return jnp.roll(f, (c[0], c[1]), axis=(0, 1))\n        elif self.dim == 3:\n            return jnp.roll(f, (c[0], c[1], c[2]), axis=(0, 1, 2))\n\n    return vmap(streaming_i, in_axes=(-1, 0), out_axes=-1)(f, self.c.T)\n</code></pre>"},{"location":"base/#src.base.LBMBase.update_macroscopic","title":"update_macroscopic","text":"<pre><code>update_macroscopic(f)\n</code></pre> <p>This function computes the macroscopic variables (density and velocity) based on the  distribution functions (f).</p> <p>The density is computed as the sum of the distribution functions over all lattice directions.  The velocity is computed as the dot product of the distribution functions and the lattice  velocities, divided by the density.</p>"},{"location":"base/#src.base.LBMBase.update_macroscopic--parameters","title":"Parameters","text":"<p>f: jax.numpy.ndarray     The distribution functions.</p>"},{"location":"base/#src.base.LBMBase.update_macroscopic--returns","title":"Returns","text":"<p>rho: jax.numpy.ndarray     Computed density. u: jax.numpy.ndarray     Computed velocity.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef update_macroscopic(self, f):\n    \"\"\"\n    This function computes the macroscopic variables (density and velocity) based on the \n    distribution functions (f).\n\n    The density is computed as the sum of the distribution functions over all lattice directions. \n    The velocity is computed as the dot product of the distribution functions and the lattice \n    velocities, divided by the density.\n\n    Parameters\n    ----------\n    f: jax.numpy.ndarray\n        The distribution functions.\n\n    Returns\n    -------\n    rho: jax.numpy.ndarray\n        Computed density.\n    u: jax.numpy.ndarray\n        Computed velocity.\n    \"\"\"\n    rho =jnp.sum(f, axis=-1, keepdims=True)\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n    u = jnp.dot(f, c) / rho\n\n    return rho, u\n</code></pre>"},{"location":"boundary_conditions/","title":"XLB boundary conditions","text":"<p>               Bases: <code>object</code></p> <p>Base class for boundary conditions in a LBM simulation.</p> <p>This class provides a general structure for implementing boundary conditions. It includes methods for preparing the boundary attributes and for applying the boundary condition. Specific boundary conditions should be implemented as subclasses of this class, with the <code>apply</code> method overridden as necessary.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Bounce-back boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements a full-way bounce-back boundary condition, where particles hitting the boundary are reflected back in the direction they came from. The boundary condition is applied after the collision step.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Moving bounce-back boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements a moving bounce-back boundary condition, where particles hitting the boundary are reflected back in the direction they came from, with an additional velocity due to the movement of the boundary. The boundary condition is applied after the collision step.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Halfway bounce-back boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements a halfway bounce-back boundary condition. The boundary condition is applied after the streaming step.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Equilibrium boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements an equilibrium boundary condition, where the distribution function at the boundary nodes is set to the equilibrium distribution function. The boundary condition is applied after the streaming step.</p> <p>               Bases: <code>BoundaryCondition</code></p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class DoNothing(BoundaryCondition):\n    def __init__(self, indices, gridInfo, precision_policy):\n        \"\"\"\n        Do-nothing boundary condition for a lattice Boltzmann method simulation.\n\n        This class implements a do-nothing boundary condition, where no action is taken at the boundary nodes. The boundary\n        condition is applied after the streaming step.\n\n        Attributes\n        ----------\n        name : str\n            The name of the boundary condition. For this class, it is \"DoNothing\".\n        implementationStep : str\n            The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n            it is \"PostStreaming\".\n\n        Notes\n        -----\n        This boundary condition enforces skipping of streaming altogether as it sets post-streaming equal to post-collision\n        populations (so no streaming at this BC voxels). The problem with returning post-streaming values or \"fout[self.indices]\n        is that the information that exit the domain on the opposite side of this boundary, would \"re-enter\". This is because\n        we roll the entire array and so the boundary condition acts like a one-way periodic BC. If EquilibriumBC is used as\n        the BC for that opposite boundary, then the rolled-in values are taken from the initial condition at equilibrium.\n        Otherwise if ZouHe is used for example the simulation looks like a run-down simulation at low-Re. The opposite boundary\n        may be even a wall (consider pipebend example). If we correct imissing directions and assign \"fin\", this method becomes\n        much less stable and also one needs to correctly take care of corner cases.\n        \"\"\"\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"DoNothing\"\n        self.implementationStep = \"PostStreaming\"\n\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the do-nothing boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the do-nothing boundary condition by simply returning the input distribution functions at the\n        boundary nodes.\n        \"\"\"\n        return fin[self.indices]\n</code></pre> <p>               Bases: <code>BoundaryCondition</code></p> <p>Zou-He boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements the Zou-He boundary condition, which is a non-equilibrium bounce-back boundary condition. It can be used to set inflow and outflow boundary conditions with prescribed pressure or velocity.</p> <p>               Bases: <code>ZouHe</code></p> <p>Regularized boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements the regularized boundary condition, which is a non-equilibrium bounce-back boundary condition with additional regularization. It can be used to set inflow and outflow boundary conditions with prescribed pressure or velocity.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Extrapolation outflow boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements the extrapolation outflow boundary condition, which is a type of outflow boundary condition that uses extrapolation to avoid strong wave reflections.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition--attributes","title":"Attributes","text":"<p>lattice : Lattice     The lattice used in the simulation. nx:     The number of nodes in the x direction. ny:     The number of nodes in the y direction. nz:     The number of nodes in the z direction. dim : int     The number of dimensions in the simulation (2 or 3). precision_policy : PrecisionPolicy     The precision policy used in the simulation. indices : array-like     The indices of the boundary nodes. name : str or None     The name of the boundary condition. This should be set in subclasses. isSolid : bool     Whether the boundary condition is for a solid boundary. This should be set in subclasses. isDynamic : bool     Whether the boundary condition is dynamic (changes over time). This should be set in subclasses. needsExtraConfiguration : bool     Whether the boundary condition requires extra configuration. This should be set in subclasses. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. This should be set in subclasses.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class BoundaryCondition(object):\n    \"\"\"\n    Base class for boundary conditions in a LBM simulation.\n\n    This class provides a general structure for implementing boundary conditions. It includes methods for preparing the\n    boundary attributes and for applying the boundary condition. Specific boundary conditions should be implemented as\n    subclasses of this class, with the `apply` method overridden as necessary.\n\n    Attributes\n    ----------\n    lattice : Lattice\n        The lattice used in the simulation.\n    nx:\n        The number of nodes in the x direction.\n    ny:\n        The number of nodes in the y direction.\n    nz:\n        The number of nodes in the z direction.\n    dim : int\n        The number of dimensions in the simulation (2 or 3).\n    precision_policy : PrecisionPolicy\n        The precision policy used in the simulation.\n    indices : array-like\n        The indices of the boundary nodes.\n    name : str or None\n        The name of the boundary condition. This should be set in subclasses.\n    isSolid : bool\n        Whether the boundary condition is for a solid boundary. This should be set in subclasses.\n    isDynamic : bool\n        Whether the boundary condition is dynamic (changes over time). This should be set in subclasses.\n    needsExtraConfiguration : bool\n        Whether the boundary condition requires extra configuration. This should be set in subclasses.\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. This should be set in subclasses.\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy):\n        self.lattice = gridInfo[\"lattice\"]\n        self.nx = gridInfo[\"nx\"]\n        self.ny = gridInfo[\"ny\"]\n        self.nz = gridInfo[\"nz\"]\n        self.dim = gridInfo[\"dim\"]\n        self.precisionPolicy = precision_policy\n        self.indices = indices\n        self.name = None\n        self.isSolid = False\n        self.isDynamic = False\n        self.needsExtraConfiguration = False\n        self.implementationStep = \"PostStreaming\"\n\n    def create_local_mask_and_normal_arrays(self, grid_mask):\n\n        \"\"\"\n        Creates local mask and normal arrays for the boundary condition.\n\n        Parameters\n        ----------\n        grid_mask : array-like\n            The grid mask for the lattice.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method creates local mask and normal arrays for the boundary condition based on the grid mask.\n        If the boundary condition requires extra configuration, the `configure` method is called.\n        \"\"\"\n\n        if self.needsExtraConfiguration:\n            boundaryMask = self.get_boundary_mask(grid_mask)\n            self.configure(boundaryMask)\n            self.needsExtraConfiguration = False\n\n        boundaryMask = self.get_boundary_mask(grid_mask)\n        self.normals = self.get_normals(boundaryMask)\n        self.imissing, self.iknown = self.get_missing_indices(boundaryMask)\n        self.imissingMask, self.iknownMask, self.imiddleMask = self.get_missing_mask(boundaryMask)\n\n        return\n\n    def get_boundary_mask(self, grid_mask):  \n        \"\"\"\n        Add jax.device_count() to the self.indices in x-direction, and 1 to the self.indices other directions\n        This is to make sure the boundary condition is applied to the correct nodes as grid_mask is\n        expanded by (jax.device_count(), 1, 1)\n\n        Parameters\n        ----------\n        grid_mask : array-like\n            The grid mask for the lattice.\n\n        Returns\n        -------\n        boundaryMask : array-like\n        \"\"\"   \n        shifted_indices = np.array(self.indices)\n        shifted_indices[0] += device_count()\n        shifted_indices[1:] += 1\n        # Convert back to tuple\n        shifted_indices = tuple(shifted_indices)\n        boundaryMask = np.array(grid_mask[shifted_indices])\n\n        return boundaryMask\n\n    def configure(self, boundaryMask):\n        \"\"\"\n        Configures the boundary condition.\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The grid mask for the boundary voxels.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method should be overridden in subclasses if the boundary condition requires extra configuration.\n        \"\"\"\n        return\n\n    @partial(jit, static_argnums=(0, 3), inline=True)\n    def prepare_populations(self, fout, fin, implementation_step):\n        \"\"\"\n        Prepares the distribution functions for the boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The incoming distribution functions.\n        fin : jax.numpy.ndarray\n            The outgoing distribution functions.\n        implementation_step : str\n            The step in the lattice Boltzmann method algorithm at which the preparation is applied.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The prepared distribution functions.\n\n        Notes\n        -----\n        This method should be overridden in subclasses if the boundary condition requires preparation of the distribution functions during post-collision or post-streaming. See ExtrapolationBoundaryCondition for an example.\n        \"\"\"   \n        return fout\n\n    def get_normals(self, boundaryMask):\n        \"\"\"\n        Calculates the normal vectors at the boundary nodes.\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The boundary mask for the lattice.\n\n        Returns\n        -------\n        array-like\n            The normal vectors at the boundary nodes.\n\n        Notes\n        -----\n        This method calculates the normal vectors by dotting the boundary mask with the main lattice directions.\n        \"\"\"\n        main_c = self.lattice.c.T[self.lattice.main_indices]\n        m = boundaryMask[..., self.lattice.main_indices]\n        normals = -np.dot(m, main_c)\n        return normals\n\n    def get_missing_indices(self, boundaryMask):\n        \"\"\"\n        Returns two int8 arrays the same shape as boundaryMask. The non-zero entries of these arrays indicate missing\n        directions that require BCs (imissing) as well as their corresponding opposite directions (iknown).\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The boundary mask for the lattice.\n\n        Returns\n        -------\n        tuple of array-like\n            The missing and known indices for the boundary condition.\n\n        Notes\n        -----\n        This method calculates the missing and known indices based on the boundary mask. The missing indices are the\n        non-zero entries of the boundary mask, and the known indices are their corresponding opposite directions.\n        \"\"\"\n\n        # Find imissing, iknown 1-to-1 corresponding indices\n        # Note: the \"zero\" index is used as default value here and won't affect BC computations\n        nbd = len(self.indices[0])\n        imissing = np.vstack([np.arange(self.lattice.q, dtype='uint8')] * nbd)\n        iknown = np.vstack([self.lattice.opp_indices] * nbd)\n        imissing[~boundaryMask] = 0\n        iknown[~boundaryMask] = 0\n        return imissing, iknown\n\n    def get_missing_mask(self, boundaryMask):\n        \"\"\"\n        Returns three boolean arrays the same shape as boundaryMask.\n        Note: these boundary masks are useful for reduction (eg. summation) operators of selected q-directions.\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The boundary mask for the lattice.\n\n        Returns\n        -------\n        tuple of array-like\n            The missing, known, and middle masks for the boundary condition.\n\n        Notes\n        -----\n        This method calculates the missing, known, and middle masks based on the boundary mask. The missing mask\n        is the boundary mask, the known mask is the opposite directions of the missing mask, and the middle mask\n        is the directions that are neither missing nor known.\n        \"\"\"\n        # Find masks for imissing, iknown and imiddle\n        imissingMask = boundaryMask\n        iknownMask = imissingMask[:, self.lattice.opp_indices]\n        imiddleMask = ~(imissingMask | iknownMask)\n        return imissingMask, iknownMask, imiddleMask\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method should be overridden in subclasses to implement the specific boundary condition. The method should\n        modify the output distribution functions in place to apply the boundary condition.\n        \"\"\"\n        pass\n\n    @partial(jit, static_argnums=(0,))\n    def equilibrium(self, rho, u):\n        \"\"\"\n        Compute equilibrium distribution function.\n\n        Parameters\n        ----------\n        rho : jax.numpy.ndarray\n            The density at each node in the lattice.\n        u : jax.numpy.ndarray\n            The velocity at each node in the lattice.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The equilibrium distribution function at each node in the lattice.\n\n        Notes\n        -----\n        This method computes the equilibrium distribution function based on the density and velocity. The computation is\n        performed in the compute precision specified by the precision policy. The result is not cast to the output precision as\n        this is function is used inside other functions that require the compute precision.\n        \"\"\"\n        rho, u = self.precisionPolicy.cast_to_compute((rho, u))\n        c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n        cu = 3.0 * jnp.dot(u, c)\n        usqr = 1.5 * jnp.sum(u**2, axis=-1, keepdims=True)\n        feq = rho * self.lattice.w * (1.0 + 1.0 * cu + 0.5 * cu**2 - usqr)\n\n        return feq\n\n    @partial(jit, static_argnums=(0,))\n    def momentum_flux(self, fneq):\n        \"\"\"\n        Compute the momentum flux.\n\n        Parameters\n        ----------\n        fneq : jax.numpy.ndarray\n            The non-equilibrium distribution function at each node in the lattice.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The momentum flux at each node in the lattice.\n\n        Notes\n        -----\n        This method computes the momentum flux by dotting the non-equilibrium distribution function with the lattice\n        direction vectors.\n        \"\"\"\n        return jnp.dot(fneq, self.lattice.cc)\n\n    @partial(jit, static_argnums=(0,))\n    def momentum_exchange_force(self, f_poststreaming, f_postcollision):\n        \"\"\"\n        Using the momentum exchange method to compute the boundary force vector exerted on the solid geometry\n        based on [1] as described in [3]. Ref [2] shows how [1] is applicable to curved geometries only by using a\n        bounce-back method (e.g. Bouzidi) that accounts for curved boundaries.\n        NOTE: this function should be called after BC's are imposed.\n        [1] A.J.C. Ladd, Numerical simulations of particular suspensions via a discretized Boltzmann equation.\n            Part 2 (numerical results), J. Fluid Mech. 271 (1994) 311-339.\n        [2] R. Mei, D. Yu, W. Shyy, L.-S. Luo, Force evaluation in the lattice Boltzmann method involving\n            curved geometry, Phys. Rev. E 65 (2002) 041203.\n        [3] Caiazzo, A., &amp; Junk, M. (2008). Boundary forces in lattice Boltzmann: Analysis of momentum exchange\n            algorithm. Computers &amp; Mathematics with Applications, 55(7), 1415-1423.\n\n        Parameters\n        ----------\n        f_poststreaming : jax.numpy.ndarray\n            The post-streaming distribution function at each node in the lattice.\n        f_postcollision : jax.numpy.ndarray\n            The post-collision distribution function at each node in the lattice.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The force exerted on the solid geometry at each boundary node.\n\n        Notes\n        -----\n        This method computes the force exerted on the solid geometry at each boundary node using the momentum exchange method. \n        The force is computed based on the post-streaming and post-collision distribution functions. This method\n        should be called after the boundary conditions are imposed.\n        \"\"\"\n        c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        phi = f_postcollision[self.indices][bindex, self.iknown] + \\\n              f_poststreaming[self.indices][bindex, self.imissing]\n        force = jnp.sum(c[:, self.iknown] * phi, axis=-1).T\n        return force\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.apply--returns","title":"Returns","text":"<p>None</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.apply--notes","title":"Notes","text":"<p>This method should be overridden in subclasses to implement the specific boundary condition. The method should modify the output distribution functions in place to apply the boundary condition.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method should be overridden in subclasses to implement the specific boundary condition. The method should\n    modify the output distribution functions in place to apply the boundary condition.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.configure","title":"configure","text":"<pre><code>configure(boundaryMask)\n</code></pre> <p>Configures the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.configure--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The grid mask for the boundary voxels.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.configure--returns","title":"Returns","text":"<p>None</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.configure--notes","title":"Notes","text":"<p>This method should be overridden in subclasses if the boundary condition requires extra configuration.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def configure(self, boundaryMask):\n    \"\"\"\n    Configures the boundary condition.\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The grid mask for the boundary voxels.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method should be overridden in subclasses if the boundary condition requires extra configuration.\n    \"\"\"\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.create_local_mask_and_normal_arrays","title":"create_local_mask_and_normal_arrays","text":"<pre><code>create_local_mask_and_normal_arrays(grid_mask)\n</code></pre> <p>Creates local mask and normal arrays for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.create_local_mask_and_normal_arrays--parameters","title":"Parameters","text":"<p>grid_mask : array-like     The grid mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.create_local_mask_and_normal_arrays--returns","title":"Returns","text":"<p>None</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.create_local_mask_and_normal_arrays--notes","title":"Notes","text":"<p>This method creates local mask and normal arrays for the boundary condition based on the grid mask. If the boundary condition requires extra configuration, the <code>configure</code> method is called.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def create_local_mask_and_normal_arrays(self, grid_mask):\n\n    \"\"\"\n    Creates local mask and normal arrays for the boundary condition.\n\n    Parameters\n    ----------\n    grid_mask : array-like\n        The grid mask for the lattice.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method creates local mask and normal arrays for the boundary condition based on the grid mask.\n    If the boundary condition requires extra configuration, the `configure` method is called.\n    \"\"\"\n\n    if self.needsExtraConfiguration:\n        boundaryMask = self.get_boundary_mask(grid_mask)\n        self.configure(boundaryMask)\n        self.needsExtraConfiguration = False\n\n    boundaryMask = self.get_boundary_mask(grid_mask)\n    self.normals = self.get_normals(boundaryMask)\n    self.imissing, self.iknown = self.get_missing_indices(boundaryMask)\n    self.imissingMask, self.iknownMask, self.imiddleMask = self.get_missing_mask(boundaryMask)\n\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.equilibrium","title":"equilibrium","text":"<pre><code>equilibrium(rho, u)\n</code></pre> <p>Compute equilibrium distribution function.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.equilibrium--parameters","title":"Parameters","text":"<p>rho : jax.numpy.ndarray     The density at each node in the lattice. u : jax.numpy.ndarray     The velocity at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.equilibrium--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The equilibrium distribution function at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.equilibrium--notes","title":"Notes","text":"<p>This method computes the equilibrium distribution function based on the density and velocity. The computation is performed in the compute precision specified by the precision policy. The result is not cast to the output precision as this is function is used inside other functions that require the compute precision.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef equilibrium(self, rho, u):\n    \"\"\"\n    Compute equilibrium distribution function.\n\n    Parameters\n    ----------\n    rho : jax.numpy.ndarray\n        The density at each node in the lattice.\n    u : jax.numpy.ndarray\n        The velocity at each node in the lattice.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The equilibrium distribution function at each node in the lattice.\n\n    Notes\n    -----\n    This method computes the equilibrium distribution function based on the density and velocity. The computation is\n    performed in the compute precision specified by the precision policy. The result is not cast to the output precision as\n    this is function is used inside other functions that require the compute precision.\n    \"\"\"\n    rho, u = self.precisionPolicy.cast_to_compute((rho, u))\n    c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n    cu = 3.0 * jnp.dot(u, c)\n    usqr = 1.5 * jnp.sum(u**2, axis=-1, keepdims=True)\n    feq = rho * self.lattice.w * (1.0 + 1.0 * cu + 0.5 * cu**2 - usqr)\n\n    return feq\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_boundary_mask","title":"get_boundary_mask","text":"<pre><code>get_boundary_mask(grid_mask)\n</code></pre> <p>Add jax.device_count() to the self.indices in x-direction, and 1 to the self.indices other directions This is to make sure the boundary condition is applied to the correct nodes as grid_mask is expanded by (jax.device_count(), 1, 1)</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_boundary_mask--parameters","title":"Parameters","text":"<p>grid_mask : array-like     The grid mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_boundary_mask--returns","title":"Returns","text":"<p>boundaryMask : array-like</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def get_boundary_mask(self, grid_mask):  \n    \"\"\"\n    Add jax.device_count() to the self.indices in x-direction, and 1 to the self.indices other directions\n    This is to make sure the boundary condition is applied to the correct nodes as grid_mask is\n    expanded by (jax.device_count(), 1, 1)\n\n    Parameters\n    ----------\n    grid_mask : array-like\n        The grid mask for the lattice.\n\n    Returns\n    -------\n    boundaryMask : array-like\n    \"\"\"   \n    shifted_indices = np.array(self.indices)\n    shifted_indices[0] += device_count()\n    shifted_indices[1:] += 1\n    # Convert back to tuple\n    shifted_indices = tuple(shifted_indices)\n    boundaryMask = np.array(grid_mask[shifted_indices])\n\n    return boundaryMask\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_indices","title":"get_missing_indices","text":"<pre><code>get_missing_indices(boundaryMask)\n</code></pre> <p>Returns two int8 arrays the same shape as boundaryMask. The non-zero entries of these arrays indicate missing directions that require BCs (imissing) as well as their corresponding opposite directions (iknown).</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_indices--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The boundary mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_indices--returns","title":"Returns","text":"<p>tuple of array-like     The missing and known indices for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_indices--notes","title":"Notes","text":"<p>This method calculates the missing and known indices based on the boundary mask. The missing indices are the non-zero entries of the boundary mask, and the known indices are their corresponding opposite directions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def get_missing_indices(self, boundaryMask):\n    \"\"\"\n    Returns two int8 arrays the same shape as boundaryMask. The non-zero entries of these arrays indicate missing\n    directions that require BCs (imissing) as well as their corresponding opposite directions (iknown).\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The boundary mask for the lattice.\n\n    Returns\n    -------\n    tuple of array-like\n        The missing and known indices for the boundary condition.\n\n    Notes\n    -----\n    This method calculates the missing and known indices based on the boundary mask. The missing indices are the\n    non-zero entries of the boundary mask, and the known indices are their corresponding opposite directions.\n    \"\"\"\n\n    # Find imissing, iknown 1-to-1 corresponding indices\n    # Note: the \"zero\" index is used as default value here and won't affect BC computations\n    nbd = len(self.indices[0])\n    imissing = np.vstack([np.arange(self.lattice.q, dtype='uint8')] * nbd)\n    iknown = np.vstack([self.lattice.opp_indices] * nbd)\n    imissing[~boundaryMask] = 0\n    iknown[~boundaryMask] = 0\n    return imissing, iknown\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_mask","title":"get_missing_mask","text":"<pre><code>get_missing_mask(boundaryMask)\n</code></pre> <p>Returns three boolean arrays the same shape as boundaryMask. Note: these boundary masks are useful for reduction (eg. summation) operators of selected q-directions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_mask--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The boundary mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_mask--returns","title":"Returns","text":"<p>tuple of array-like     The missing, known, and middle masks for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_mask--notes","title":"Notes","text":"<p>This method calculates the missing, known, and middle masks based on the boundary mask. The missing mask is the boundary mask, the known mask is the opposite directions of the missing mask, and the middle mask is the directions that are neither missing nor known.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def get_missing_mask(self, boundaryMask):\n    \"\"\"\n    Returns three boolean arrays the same shape as boundaryMask.\n    Note: these boundary masks are useful for reduction (eg. summation) operators of selected q-directions.\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The boundary mask for the lattice.\n\n    Returns\n    -------\n    tuple of array-like\n        The missing, known, and middle masks for the boundary condition.\n\n    Notes\n    -----\n    This method calculates the missing, known, and middle masks based on the boundary mask. The missing mask\n    is the boundary mask, the known mask is the opposite directions of the missing mask, and the middle mask\n    is the directions that are neither missing nor known.\n    \"\"\"\n    # Find masks for imissing, iknown and imiddle\n    imissingMask = boundaryMask\n    iknownMask = imissingMask[:, self.lattice.opp_indices]\n    imiddleMask = ~(imissingMask | iknownMask)\n    return imissingMask, iknownMask, imiddleMask\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_normals","title":"get_normals","text":"<pre><code>get_normals(boundaryMask)\n</code></pre> <p>Calculates the normal vectors at the boundary nodes.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_normals--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The boundary mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_normals--returns","title":"Returns","text":"<p>array-like     The normal vectors at the boundary nodes.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_normals--notes","title":"Notes","text":"<p>This method calculates the normal vectors by dotting the boundary mask with the main lattice directions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def get_normals(self, boundaryMask):\n    \"\"\"\n    Calculates the normal vectors at the boundary nodes.\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The boundary mask for the lattice.\n\n    Returns\n    -------\n    array-like\n        The normal vectors at the boundary nodes.\n\n    Notes\n    -----\n    This method calculates the normal vectors by dotting the boundary mask with the main lattice directions.\n    \"\"\"\n    main_c = self.lattice.c.T[self.lattice.main_indices]\n    m = boundaryMask[..., self.lattice.main_indices]\n    normals = -np.dot(m, main_c)\n    return normals\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_exchange_force","title":"momentum_exchange_force","text":"<pre><code>momentum_exchange_force(f_poststreaming, f_postcollision)\n</code></pre> <p>Using the momentum exchange method to compute the boundary force vector exerted on the solid geometry based on [1] as described in [3]. Ref [2] shows how [1] is applicable to curved geometries only by using a bounce-back method (e.g. Bouzidi) that accounts for curved boundaries. NOTE: this function should be called after BC\u2019s are imposed. [1] A.J.C. Ladd, Numerical simulations of particular suspensions via a discretized Boltzmann equation.     Part 2 (numerical results), J. Fluid Mech. 271 (1994) 311-339. [2] R. Mei, D. Yu, W. Shyy, L.-S. Luo, Force evaluation in the lattice Boltzmann method involving     curved geometry, Phys. Rev. E 65 (2002) 041203. [3] Caiazzo, A., &amp; Junk, M. (2008). Boundary forces in lattice Boltzmann: Analysis of momentum exchange     algorithm. Computers &amp; Mathematics with Applications, 55(7), 1415-1423.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_exchange_force--parameters","title":"Parameters","text":"<p>f_poststreaming : jax.numpy.ndarray     The post-streaming distribution function at each node in the lattice. f_postcollision : jax.numpy.ndarray     The post-collision distribution function at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_exchange_force--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The force exerted on the solid geometry at each boundary node.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_exchange_force--notes","title":"Notes","text":"<p>This method computes the force exerted on the solid geometry at each boundary node using the momentum exchange method.  The force is computed based on the post-streaming and post-collision distribution functions. This method should be called after the boundary conditions are imposed.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef momentum_exchange_force(self, f_poststreaming, f_postcollision):\n    \"\"\"\n    Using the momentum exchange method to compute the boundary force vector exerted on the solid geometry\n    based on [1] as described in [3]. Ref [2] shows how [1] is applicable to curved geometries only by using a\n    bounce-back method (e.g. Bouzidi) that accounts for curved boundaries.\n    NOTE: this function should be called after BC's are imposed.\n    [1] A.J.C. Ladd, Numerical simulations of particular suspensions via a discretized Boltzmann equation.\n        Part 2 (numerical results), J. Fluid Mech. 271 (1994) 311-339.\n    [2] R. Mei, D. Yu, W. Shyy, L.-S. Luo, Force evaluation in the lattice Boltzmann method involving\n        curved geometry, Phys. Rev. E 65 (2002) 041203.\n    [3] Caiazzo, A., &amp; Junk, M. (2008). Boundary forces in lattice Boltzmann: Analysis of momentum exchange\n        algorithm. Computers &amp; Mathematics with Applications, 55(7), 1415-1423.\n\n    Parameters\n    ----------\n    f_poststreaming : jax.numpy.ndarray\n        The post-streaming distribution function at each node in the lattice.\n    f_postcollision : jax.numpy.ndarray\n        The post-collision distribution function at each node in the lattice.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The force exerted on the solid geometry at each boundary node.\n\n    Notes\n    -----\n    This method computes the force exerted on the solid geometry at each boundary node using the momentum exchange method. \n    The force is computed based on the post-streaming and post-collision distribution functions. This method\n    should be called after the boundary conditions are imposed.\n    \"\"\"\n    c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    phi = f_postcollision[self.indices][bindex, self.iknown] + \\\n          f_poststreaming[self.indices][bindex, self.imissing]\n    force = jnp.sum(c[:, self.iknown] * phi, axis=-1).T\n    return force\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_flux","title":"momentum_flux","text":"<pre><code>momentum_flux(fneq)\n</code></pre> <p>Compute the momentum flux.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_flux--parameters","title":"Parameters","text":"<p>fneq : jax.numpy.ndarray     The non-equilibrium distribution function at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_flux--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The momentum flux at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_flux--notes","title":"Notes","text":"<p>This method computes the momentum flux by dotting the non-equilibrium distribution function with the lattice direction vectors.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef momentum_flux(self, fneq):\n    \"\"\"\n    Compute the momentum flux.\n\n    Parameters\n    ----------\n    fneq : jax.numpy.ndarray\n        The non-equilibrium distribution function at each node in the lattice.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The momentum flux at each node in the lattice.\n\n    Notes\n    -----\n    This method computes the momentum flux by dotting the non-equilibrium distribution function with the lattice\n    direction vectors.\n    \"\"\"\n    return jnp.dot(fneq, self.lattice.cc)\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.prepare_populations","title":"prepare_populations","text":"<pre><code>prepare_populations(fout, fin, implementation_step)\n</code></pre> <p>Prepares the distribution functions for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.prepare_populations--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The incoming distribution functions. fin : jax.numpy.ndarray     The outgoing distribution functions. implementation_step : str     The step in the lattice Boltzmann method algorithm at which the preparation is applied.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.prepare_populations--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The prepared distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.prepare_populations--notes","title":"Notes","text":"<p>This method should be overridden in subclasses if the boundary condition requires preparation of the distribution functions during post-collision or post-streaming. See ExtrapolationBoundaryCondition for an example.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), inline=True)\ndef prepare_populations(self, fout, fin, implementation_step):\n    \"\"\"\n    Prepares the distribution functions for the boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The incoming distribution functions.\n    fin : jax.numpy.ndarray\n        The outgoing distribution functions.\n    implementation_step : str\n        The step in the lattice Boltzmann method algorithm at which the preparation is applied.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The prepared distribution functions.\n\n    Notes\n    -----\n    This method should be overridden in subclasses if the boundary condition requires preparation of the distribution functions during post-collision or post-streaming. See ExtrapolationBoundaryCondition for an example.\n    \"\"\"   \n    return fout\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cBounceBackFullway\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostCollision\u201d.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class BounceBack(BoundaryCondition):\n    \"\"\"\n    Bounce-back boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements a full-way bounce-back boundary condition, where particles hitting the boundary are reflected\n    back in the direction they came from. The boundary condition is applied after the collision step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"BounceBackFullway\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostCollision\".\n    \"\"\"\n    def __init__(self, indices, gridInfo, precision_policy):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"BounceBackFullway\"\n        self.implementationStep = \"PostCollision\"\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the bounce-back boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the bounce-back boundary condition by reflecting the input distribution functions at the\n        boundary nodes in the opposite direction.\n        \"\"\"\n\n        return fin[self.indices][..., self.lattice.opp_indices]\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the bounce-back boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack.apply--notes","title":"Notes","text":"<p>This method applies the bounce-back boundary condition by reflecting the input distribution functions at the boundary nodes in the opposite direction.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the bounce-back boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the bounce-back boundary condition by reflecting the input distribution functions at the\n    boundary nodes in the opposite direction.\n    \"\"\"\n\n    return fin[self.indices][..., self.lattice.opp_indices]\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackMoving--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cBounceBackFullwayMoving\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostCollision\u201d. isDynamic : bool     Whether the boundary condition is dynamic (changes over time). For this class, it is True. update_function : function     A function that updates the boundary condition. For this class, it is a function that updates the boundary     condition based on the current time step. The signature of the function is <code>update_function(time) -&gt; (indices, vel)</code>,</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class BounceBackMoving(BoundaryCondition):\n    \"\"\"\n    Moving bounce-back boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements a moving bounce-back boundary condition, where particles hitting the boundary are reflected\n    back in the direction they came from, with an additional velocity due to the movement of the boundary. The boundary\n    condition is applied after the collision step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"BounceBackFullwayMoving\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostCollision\".\n    isDynamic : bool\n        Whether the boundary condition is dynamic (changes over time). For this class, it is True.\n    update_function : function\n        A function that updates the boundary condition. For this class, it is a function that updates the boundary\n        condition based on the current time step. The signature of the function is `update_function(time) -&gt; (indices, vel)`,\n\n    \"\"\"\n    def __init__(self, gridInfo, precision_policy, update_function=None):\n        # We get the indices at time zero to pass to the parent class for initialization\n        indices, _ = update_function(0)\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"BounceBackFullwayMoving\"\n        self.implementationStep = \"PostCollision\"\n        self.isDynamic = True\n        self.update_function = jit(update_function)\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin, time):\n        \"\"\"\n        Applies the moving bounce-back boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n        time : int\n            The current time step.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n        \"\"\"\n        indices, vel = self.update_function(time)\n        c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n        cu = 6.0 * self.lattice.w * jnp.dot(vel, c)\n        return fout.at[indices].set(fin[indices][..., self.lattice.opp_indices] - cu)\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackMoving.apply","title":"apply","text":"<pre><code>apply(fout, fin, time)\n</code></pre> <p>Applies the moving bounce-back boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackMoving.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions. time : int     The current time step.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackMoving.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin, time):\n    \"\"\"\n    Applies the moving bounce-back boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n    time : int\n        The current time step.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n    \"\"\"\n    indices, vel = self.update_function(time)\n    c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n    cu = 6.0 * self.lattice.w * jnp.dot(vel, c)\n    return fout.at[indices].set(fin[indices][..., self.lattice.opp_indices] - cu)\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cBounceBackHalfway\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostStreaming\u201d. needsExtraConfiguration : bool     Whether the boundary condition needs extra configuration before it can be applied. For this class, it is True. isSolid : bool     Whether the boundary condition represents a solid boundary. For this class, it is True. vel : array-like     The prescribed value of velocity vector for the boundary condition. No-slip BC is assumed if vel=None (default).</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class BounceBackHalfway(BoundaryCondition):\n    \"\"\"\n    Halfway bounce-back boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements a halfway bounce-back boundary condition. The boundary condition is applied after\n    the streaming step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"BounceBackHalfway\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostStreaming\".\n    needsExtraConfiguration : bool\n        Whether the boundary condition needs extra configuration before it can be applied. For this class, it is True.\n    isSolid : bool\n        Whether the boundary condition represents a solid boundary. For this class, it is True.\n    vel : array-like\n        The prescribed value of velocity vector for the boundary condition. No-slip BC is assumed if vel=None (default).\n    \"\"\"\n    def __init__(self, indices, gridInfo, precision_policy, vel=None):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"BounceBackHalfway\"\n        self.implementationStep = \"PostStreaming\"\n        self.needsExtraConfiguration = True\n        self.isSolid = True\n        self.vel = vel\n\n    def configure(self, boundaryMask):\n        \"\"\"\n        Configures the boundary condition.\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The grid mask for the boundary voxels.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method performs an index shift for the halfway bounce-back boundary condition. It updates the indices of\n        the boundary nodes to be the indices of fluid nodes adjacent of the solid nodes.\n        \"\"\"\n        # Perform index shift for halfway BB.\n        hasFluidNeighbour = ~boundaryMask[:, self.lattice.opp_indices]\n        nbd_orig = len(self.indices[0])\n        idx = np.array(self.indices).T\n        idx_trg = []\n        for i in range(self.lattice.q):\n            idx_trg.append(idx[hasFluidNeighbour[:, i], :] + self.lattice.c[:, i])\n        indices_new = np.unique(np.vstack(idx_trg), axis=0)\n        self.indices = tuple(indices_new.T)\n        nbd_modified = len(self.indices[0])\n        if (nbd_orig != nbd_modified) and self.vel is not None:\n            vel_avg = np.mean(self.vel, axis=0)\n            self.vel = jnp.zeros(indices_new.shape, dtype=self.precisionPolicy.compute_dtype) + vel_avg\n            print(\"WARNING: assuming a constant averaged velocity vector is imposed at all BC cells!\")\n\n        return\n\n    @partial(jit, static_argnums=(0,))\n    def impose_boundary_vel(self, fbd, bindex):\n        c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n        cu = 6.0 * self.lattice.w * jnp.dot(self.vel, c)\n        fbd = fbd.at[bindex, self.imissing].add(-cu[bindex, self.iknown])\n        return fbd\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the halfway bounce-back boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n        \"\"\"\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        fbd = fout[self.indices]\n\n        fbd = fbd.at[bindex, self.imissing].set(fin[self.indices][bindex, self.iknown])\n        if self.vel is not None:\n            fbd = self.impose_boundary_vel(fbd, bindex)\n        return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the halfway bounce-back boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the halfway bounce-back boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n    \"\"\"\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    fbd = fout[self.indices]\n\n    fbd = fbd.at[bindex, self.imissing].set(fin[self.indices][bindex, self.iknown])\n    if self.vel is not None:\n        fbd = self.impose_boundary_vel(fbd, bindex)\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.configure","title":"configure","text":"<pre><code>configure(boundaryMask)\n</code></pre> <p>Configures the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.configure--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The grid mask for the boundary voxels.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.configure--returns","title":"Returns","text":"<p>None</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.configure--notes","title":"Notes","text":"<p>This method performs an index shift for the halfway bounce-back boundary condition. It updates the indices of the boundary nodes to be the indices of fluid nodes adjacent of the solid nodes.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def configure(self, boundaryMask):\n    \"\"\"\n    Configures the boundary condition.\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The grid mask for the boundary voxels.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method performs an index shift for the halfway bounce-back boundary condition. It updates the indices of\n    the boundary nodes to be the indices of fluid nodes adjacent of the solid nodes.\n    \"\"\"\n    # Perform index shift for halfway BB.\n    hasFluidNeighbour = ~boundaryMask[:, self.lattice.opp_indices]\n    nbd_orig = len(self.indices[0])\n    idx = np.array(self.indices).T\n    idx_trg = []\n    for i in range(self.lattice.q):\n        idx_trg.append(idx[hasFluidNeighbour[:, i], :] + self.lattice.c[:, i])\n    indices_new = np.unique(np.vstack(idx_trg), axis=0)\n    self.indices = tuple(indices_new.T)\n    nbd_modified = len(self.indices[0])\n    if (nbd_orig != nbd_modified) and self.vel is not None:\n        vel_avg = np.mean(self.vel, axis=0)\n        self.vel = jnp.zeros(indices_new.shape, dtype=self.precisionPolicy.compute_dtype) + vel_avg\n        print(\"WARNING: assuming a constant averaged velocity vector is imposed at all BC cells!\")\n\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cEquilibriumBC\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostStreaming\u201d. out : jax.numpy.ndarray     The equilibrium distribution function at the boundary nodes.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class EquilibriumBC(BoundaryCondition):\n    \"\"\"\n    Equilibrium boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements an equilibrium boundary condition, where the distribution function at the boundary nodes is\n    set to the equilibrium distribution function. The boundary condition is applied after the streaming step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"EquilibriumBC\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostStreaming\".\n    out : jax.numpy.ndarray\n        The equilibrium distribution function at the boundary nodes.\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy, rho, u):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.out = self.precisionPolicy.cast_to_output(self.equilibrium(rho, u))\n        self.name = \"EquilibriumBC\"\n        self.implementationStep = \"PostStreaming\"\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the equilibrium boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the equilibrium boundary condition by setting the output distribution functions at the\n        boundary nodes to the equilibrium distribution function.\n        \"\"\"\n        return self.out\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the equilibrium boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC.apply--notes","title":"Notes","text":"<p>This method applies the equilibrium boundary condition by setting the output distribution functions at the boundary nodes to the equilibrium distribution function.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the equilibrium boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the equilibrium boundary condition by setting the output distribution functions at the\n    boundary nodes to the equilibrium distribution function.\n    \"\"\"\n    return self.out\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.__init__","title":"__init__","text":"<pre><code>__init__(indices, gridInfo, precision_policy)\n</code></pre> <p>Do-nothing boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements a do-nothing boundary condition, where no action is taken at the boundary nodes. The boundary condition is applied after the streaming step.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.__init__--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cDoNothing\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostStreaming\u201d.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.__init__--notes","title":"Notes","text":"<p>This boundary condition enforces skipping of streaming altogether as it sets post-streaming equal to post-collision populations (so no streaming at this BC voxels). The problem with returning post-streaming values or \u201cfout[self.indices] is that the information that exit the domain on the opposite side of this boundary, would \u201cre-enter\u201d. This is because we roll the entire array and so the boundary condition acts like a one-way periodic BC. If EquilibriumBC is used as the BC for that opposite boundary, then the rolled-in values are taken from the initial condition at equilibrium. Otherwise if ZouHe is used for example the simulation looks like a run-down simulation at low-Re. The opposite boundary may be even a wall (consider pipebend example). If we correct imissing directions and assign \u201cfin\u201d, this method becomes much less stable and also one needs to correctly take care of corner cases.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def __init__(self, indices, gridInfo, precision_policy):\n    \"\"\"\n    Do-nothing boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements a do-nothing boundary condition, where no action is taken at the boundary nodes. The boundary\n    condition is applied after the streaming step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"DoNothing\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostStreaming\".\n\n    Notes\n    -----\n    This boundary condition enforces skipping of streaming altogether as it sets post-streaming equal to post-collision\n    populations (so no streaming at this BC voxels). The problem with returning post-streaming values or \"fout[self.indices]\n    is that the information that exit the domain on the opposite side of this boundary, would \"re-enter\". This is because\n    we roll the entire array and so the boundary condition acts like a one-way periodic BC. If EquilibriumBC is used as\n    the BC for that opposite boundary, then the rolled-in values are taken from the initial condition at equilibrium.\n    Otherwise if ZouHe is used for example the simulation looks like a run-down simulation at low-Re. The opposite boundary\n    may be even a wall (consider pipebend example). If we correct imissing directions and assign \"fin\", this method becomes\n    much less stable and also one needs to correctly take care of corner cases.\n    \"\"\"\n    super().__init__(indices, gridInfo, precision_policy)\n    self.name = \"DoNothing\"\n    self.implementationStep = \"PostStreaming\"\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the do-nothing boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.apply--notes","title":"Notes","text":"<p>This method applies the do-nothing boundary condition by simply returning the input distribution functions at the boundary nodes.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the do-nothing boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the do-nothing boundary condition by simply returning the input distribution functions at the\n    boundary nodes.\n    \"\"\"\n    return fin[self.indices]\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cZouHe\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostStreaming\u201d. type : str     The type of the boundary condition. It can be either \u2018velocity\u2019 for a prescribed velocity boundary condition,     or \u2018pressure\u2019 for a prescribed pressure boundary condition. prescribed : float or array-like     The prescribed values for the boundary condition. It can be either the prescribed velocities for a \u2018velocity\u2019     boundary condition, or the prescribed pressures for a \u2018pressure\u2019 boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe--references","title":"References","text":"<p>Zou, Q., &amp; He, X. (1997). On pressure and velocity boundary conditions for the lattice Boltzmann BGK model. Physics of Fluids, 9(6), 1591-1598. doi:10.1063/1.869307</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class ZouHe(BoundaryCondition):\n    \"\"\"\n    Zou-He boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements the Zou-He boundary condition, which is a non-equilibrium bounce-back boundary condition.\n    It can be used to set inflow and outflow boundary conditions with prescribed pressure or velocity.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"ZouHe\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostStreaming\".\n    type : str\n        The type of the boundary condition. It can be either 'velocity' for a prescribed velocity boundary condition,\n        or 'pressure' for a prescribed pressure boundary condition.\n    prescribed : float or array-like\n        The prescribed values for the boundary condition. It can be either the prescribed velocities for a 'velocity'\n        boundary condition, or the prescribed pressures for a 'pressure' boundary condition.\n\n    References\n    ----------\n    Zou, Q., &amp; He, X. (1997). On pressure and velocity boundary conditions for the lattice Boltzmann BGK model.\n    Physics of Fluids, 9(6), 1591-1598. doi:10.1063/1.869307\n    \"\"\"\n    def __init__(self, indices, gridInfo, precision_policy, type, prescribed):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"ZouHe\"\n        self.implementationStep = \"PostStreaming\"\n        self.type = type\n        self.prescribed = prescribed\n        self.needsExtraConfiguration = True\n\n    def configure(self, boundaryMask):\n        \"\"\"\n        Correct boundary indices to ensure that only voxelized surfaces with normal vectors along main cartesian axes\n        are assigned this type of BC.\n        \"\"\"\n        nv = np.dot(self.lattice.c, ~boundaryMask.T)\n        corner_voxels = np.count_nonzero(nv, axis=0) &gt; 1\n        # removed_voxels = np.array(self.indices)[:, corner_voxels]\n        self.indices = tuple(np.array(self.indices)[:, ~corner_voxels])\n        self.prescribed = self.prescribed[~corner_voxels]\n        return\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def calculate_vel(self, fpop, rho):\n        \"\"\"\n        Calculate velocity based on the prescribed pressure/density (Zou/He BC)\n        \"\"\"\n        unormal = -1. + 1. / rho * (jnp.sum(fpop[self.indices] * self.imiddleMask, axis=1, keepdims=True) +\n                               2. * jnp.sum(fpop[self.indices] * self.iknownMask, axis=1, keepdims=True))\n\n        # Return the above unormal as a normal vector which sets the tangential velocities to zero\n        vel = unormal * self.normals\n        return vel\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def calculate_rho(self, fpop, vel):\n        \"\"\"\n        Calculate density based on the prescribed velocity (Zou/He BC)\n        \"\"\"\n        unormal = np.sum(self.normals*vel, axis=1)\n\n        rho = (1.0/(1.0 + unormal))[..., None] * (jnp.sum(fpop[self.indices] * self.imiddleMask, axis=1, keepdims=True) +\n                                  2.*jnp.sum(fpop[self.indices] * self.iknownMask, axis=1, keepdims=True))\n        return rho\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def calculate_equilibrium(self, fpop):\n        \"\"\"\n        This is the ZouHe method of calculating the missing macroscopic variables at the boundary.\n        \"\"\"\n        if self.type == 'velocity':\n            vel = self.prescribed\n            rho = self.calculate_rho(fpop, vel)\n        elif self.type == 'pressure':\n            rho = self.prescribed\n            vel = self.calculate_vel(fpop, rho)\n        else:\n            raise ValueError(f\"type = {self.type} not supported! Use \\'pressure\\' or \\'velocity\\'.\")\n\n        # compute feq at the boundary\n        feq = self.equilibrium(rho, vel)\n        return feq\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def bounceback_nonequilibrium(self, fpop, feq):\n        \"\"\"\n        Calculate unknown populations using bounce-back of non-equilibrium populations\n        a la original Zou &amp; He formulation\n        \"\"\"\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        fbd = fpop[self.indices]\n        fknown = fpop[self.indices][bindex, self.iknown] + feq[bindex, self.imissing] - feq[bindex, self.iknown]\n        fbd = fbd.at[bindex, self.imissing].set(fknown)\n        return fbd\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, _):\n        \"\"\"\n        Applies the Zou-He boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        _ : jax.numpy.ndarray\n            The input distribution functions. This is not used in this method.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the Zou-He boundary condition by first computing the equilibrium distribution functions based\n        on the prescribed values and the type of boundary condition, and then setting the unknown distribution functions\n        based on the non-equilibrium bounce-back method. \n        Tangential velocity is not ensured to be zero by adding transverse contributions based on\n        Hecth &amp; Harting (2010) (doi:10.1088/1742-5468/2010/01/P01018) as it caused numerical instabilities at higher\n        Reynolds numbers. One needs to use \"Regularized\" BC at higher Reynolds.\n        \"\"\"\n        # compute the equilibrium based on prescribed values and the type of BC\n        feq = self.calculate_equilibrium(fout)\n\n        # set the unknown f populations based on the non-equilibrium bounce-back method\n        fbd = self.bounceback_nonequilibrium(fout, feq)\n\n\n        return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.apply","title":"apply","text":"<pre><code>apply(fout, _)\n</code></pre> <p>Applies the Zou-He boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. _ : jax.numpy.ndarray     The input distribution functions. This is not used in this method.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.apply--notes","title":"Notes","text":"<p>This method applies the Zou-He boundary condition by first computing the equilibrium distribution functions based on the prescribed values and the type of boundary condition, and then setting the unknown distribution functions based on the non-equilibrium bounce-back method.  Tangential velocity is not ensured to be zero by adding transverse contributions based on Hecth &amp; Harting (2010) (doi:10.1088/1742-5468/2010/01/P01018) as it caused numerical instabilities at higher Reynolds numbers. One needs to use \u201cRegularized\u201d BC at higher Reynolds.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, _):\n    \"\"\"\n    Applies the Zou-He boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    _ : jax.numpy.ndarray\n        The input distribution functions. This is not used in this method.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the Zou-He boundary condition by first computing the equilibrium distribution functions based\n    on the prescribed values and the type of boundary condition, and then setting the unknown distribution functions\n    based on the non-equilibrium bounce-back method. \n    Tangential velocity is not ensured to be zero by adding transverse contributions based on\n    Hecth &amp; Harting (2010) (doi:10.1088/1742-5468/2010/01/P01018) as it caused numerical instabilities at higher\n    Reynolds numbers. One needs to use \"Regularized\" BC at higher Reynolds.\n    \"\"\"\n    # compute the equilibrium based on prescribed values and the type of BC\n    feq = self.calculate_equilibrium(fout)\n\n    # set the unknown f populations based on the non-equilibrium bounce-back method\n    fbd = self.bounceback_nonequilibrium(fout, feq)\n\n\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.bounceback_nonequilibrium","title":"bounceback_nonequilibrium","text":"<pre><code>bounceback_nonequilibrium(fpop, feq)\n</code></pre> <p>Calculate unknown populations using bounce-back of non-equilibrium populations a la original Zou &amp; He formulation</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef bounceback_nonequilibrium(self, fpop, feq):\n    \"\"\"\n    Calculate unknown populations using bounce-back of non-equilibrium populations\n    a la original Zou &amp; He formulation\n    \"\"\"\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    fbd = fpop[self.indices]\n    fknown = fpop[self.indices][bindex, self.iknown] + feq[bindex, self.imissing] - feq[bindex, self.iknown]\n    fbd = fbd.at[bindex, self.imissing].set(fknown)\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.calculate_equilibrium","title":"calculate_equilibrium","text":"<pre><code>calculate_equilibrium(fpop)\n</code></pre> <p>This is the ZouHe method of calculating the missing macroscopic variables at the boundary.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef calculate_equilibrium(self, fpop):\n    \"\"\"\n    This is the ZouHe method of calculating the missing macroscopic variables at the boundary.\n    \"\"\"\n    if self.type == 'velocity':\n        vel = self.prescribed\n        rho = self.calculate_rho(fpop, vel)\n    elif self.type == 'pressure':\n        rho = self.prescribed\n        vel = self.calculate_vel(fpop, rho)\n    else:\n        raise ValueError(f\"type = {self.type} not supported! Use \\'pressure\\' or \\'velocity\\'.\")\n\n    # compute feq at the boundary\n    feq = self.equilibrium(rho, vel)\n    return feq\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.calculate_rho","title":"calculate_rho","text":"<pre><code>calculate_rho(fpop, vel)\n</code></pre> <p>Calculate density based on the prescribed velocity (Zou/He BC)</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef calculate_rho(self, fpop, vel):\n    \"\"\"\n    Calculate density based on the prescribed velocity (Zou/He BC)\n    \"\"\"\n    unormal = np.sum(self.normals*vel, axis=1)\n\n    rho = (1.0/(1.0 + unormal))[..., None] * (jnp.sum(fpop[self.indices] * self.imiddleMask, axis=1, keepdims=True) +\n                              2.*jnp.sum(fpop[self.indices] * self.iknownMask, axis=1, keepdims=True))\n    return rho\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.calculate_vel","title":"calculate_vel","text":"<pre><code>calculate_vel(fpop, rho)\n</code></pre> <p>Calculate velocity based on the prescribed pressure/density (Zou/He BC)</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef calculate_vel(self, fpop, rho):\n    \"\"\"\n    Calculate velocity based on the prescribed pressure/density (Zou/He BC)\n    \"\"\"\n    unormal = -1. + 1. / rho * (jnp.sum(fpop[self.indices] * self.imiddleMask, axis=1, keepdims=True) +\n                           2. * jnp.sum(fpop[self.indices] * self.iknownMask, axis=1, keepdims=True))\n\n    # Return the above unormal as a normal vector which sets the tangential velocities to zero\n    vel = unormal * self.normals\n    return vel\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.configure","title":"configure","text":"<pre><code>configure(boundaryMask)\n</code></pre> <p>Correct boundary indices to ensure that only voxelized surfaces with normal vectors along main cartesian axes are assigned this type of BC.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def configure(self, boundaryMask):\n    \"\"\"\n    Correct boundary indices to ensure that only voxelized surfaces with normal vectors along main cartesian axes\n    are assigned this type of BC.\n    \"\"\"\n    nv = np.dot(self.lattice.c, ~boundaryMask.T)\n    corner_voxels = np.count_nonzero(nv, axis=0) &gt; 1\n    # removed_voxels = np.array(self.indices)[:, corner_voxels]\n    self.indices = tuple(np.array(self.indices)[:, ~corner_voxels])\n    self.prescribed = self.prescribed[~corner_voxels]\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cRegularized\u201d. Qi : numpy.ndarray     The Qi tensor, which is used in the regularization of the distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized--references","title":"References","text":"<p>Latt, J. (2007). Hydrodynamic limit of lattice Boltzmann equations. PhD thesis, University of Geneva. Latt, J., Chopard, B., Malaspinas, O., Deville, M., &amp; Michler, A. (2008). Straight velocity boundaries in the lattice Boltzmann method. Physical Review E, 77(5), 056703. doi:10.1103/PhysRevE.77.056703</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class Regularized(ZouHe):\n    \"\"\"\n    Regularized boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements the regularized boundary condition, which is a non-equilibrium bounce-back boundary condition\n    with additional regularization. It can be used to set inflow and outflow boundary conditions with prescribed pressure\n    or velocity.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"Regularized\".\n    Qi : numpy.ndarray\n        The Qi tensor, which is used in the regularization of the distribution functions.\n\n    References\n    ----------\n    Latt, J. (2007). Hydrodynamic limit of lattice Boltzmann equations. PhD thesis, University of Geneva.\n    Latt, J., Chopard, B., Malaspinas, O., Deville, M., &amp; Michler, A. (2008). Straight velocity boundaries in the\n    lattice Boltzmann method. Physical Review E, 77(5), 056703. doi:10.1103/PhysRevE.77.056703\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy, type, prescribed):\n        super().__init__(indices, gridInfo, precision_policy, type, prescribed)\n        self.name = \"Regularized\"\n        #TODO for Hesam: check to understand why corner cases cause instability here.\n        # self.needsExtraConfiguration = False\n        self.construct_symmetric_lattice_moment()\n\n    def construct_symmetric_lattice_moment(self):\n        \"\"\"\n        Construct the symmetric lattice moment Qi.\n\n        The Qi tensor is used in the regularization of the distribution functions. It is defined as Qi = cc - cs^2*I,\n        where cc is the tensor of lattice velocities, cs is the speed of sound, and I is the identity tensor.\n        \"\"\"\n        Qi = self.lattice.cc\n        if self.dim == 3:\n            diagonal = (0, 3, 5)\n            offdiagonal = (1, 2, 4)\n        elif self.dim == 2:\n            diagonal = (0, 2)\n            offdiagonal = (1,)\n        else:\n            raise ValueError(f\"dim = {self.dim} not supported\")\n\n        # Qi = cc - cs^2*I\n        Qi = Qi.at[:, diagonal].set(self.lattice.cc[:, diagonal] - 1./3.)\n\n        # multiply off-diagonal elements by 2 because the Q tensor is symmetric\n        Qi = Qi.at[:, offdiagonal].set(self.lattice.cc[:, offdiagonal] * 2.0)\n\n        self.Qi = Qi.T\n        return\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def regularize_fpop(self, fpop, feq):\n        \"\"\"\n        Regularizes the distribution functions by adding non-equilibrium contributions based on second moments of fpop.\n\n        Parameters\n        ----------\n        fpop : jax.numpy.ndarray\n            The distribution functions.\n        feq : jax.numpy.ndarray\n            The equilibrium distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The regularized distribution functions.\n        \"\"\"\n\n        # Compute momentum flux of off-equilibrium populations for regularization: Pi^1 = Pi^{neq}\n        f_neq = fpop - feq\n        PiNeq = self.momentum_flux(f_neq)\n        # PiNeq = self.momentum_flux(fpop) - self.momentum_flux(feq)\n\n        # Compute double dot product Qi:Pi1\n        # QiPi1 = np.zeros_like(fpop)\n        # Pi1 = PiNeq\n        # QiPi1 = jnp.dot(Qi, Pi1)\n        QiPi1 = jnp.dot(PiNeq, self.Qi)\n\n        # assign all populations based on eq 45 of Latt et al (2008)\n        # fneq ~ f^1\n        fpop1 = 9. / 2. * self.lattice.w[None, :] * QiPi1\n        fpop_regularized = feq + fpop1\n\n        return fpop_regularized\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, _):\n        \"\"\"\n        Applies the regularized boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        _ : jax.numpy.ndarray\n            The input distribution functions. This is not used in this method.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the regularized boundary condition by first computing the equilibrium distribution functions based\n        on the prescribed values and the type of boundary condition, then setting the unknown distribution functions\n        based on the non-equilibrium bounce-back method, and finally regularizing the distribution functions.\n        \"\"\"\n\n        # compute the equilibrium based on prescribed values and the type of BC\n        feq = self.calculate_equilibrium(fout)\n\n        # set the unknown f populations based on the non-equilibrium bounce-back method\n        fbd = self.bounceback_nonequilibrium(fout, feq)\n\n        # Regularize the boundary fpop\n        fbd = self.regularize_fpop(fbd, feq)\n        return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.apply","title":"apply","text":"<pre><code>apply(fout, _)\n</code></pre> <p>Applies the regularized boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. _ : jax.numpy.ndarray     The input distribution functions. This is not used in this method.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.apply--notes","title":"Notes","text":"<p>This method applies the regularized boundary condition by first computing the equilibrium distribution functions based on the prescribed values and the type of boundary condition, then setting the unknown distribution functions based on the non-equilibrium bounce-back method, and finally regularizing the distribution functions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, _):\n    \"\"\"\n    Applies the regularized boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    _ : jax.numpy.ndarray\n        The input distribution functions. This is not used in this method.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the regularized boundary condition by first computing the equilibrium distribution functions based\n    on the prescribed values and the type of boundary condition, then setting the unknown distribution functions\n    based on the non-equilibrium bounce-back method, and finally regularizing the distribution functions.\n    \"\"\"\n\n    # compute the equilibrium based on prescribed values and the type of BC\n    feq = self.calculate_equilibrium(fout)\n\n    # set the unknown f populations based on the non-equilibrium bounce-back method\n    fbd = self.bounceback_nonequilibrium(fout, feq)\n\n    # Regularize the boundary fpop\n    fbd = self.regularize_fpop(fbd, feq)\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.construct_symmetric_lattice_moment","title":"construct_symmetric_lattice_moment","text":"<pre><code>construct_symmetric_lattice_moment()\n</code></pre> <p>Construct the symmetric lattice moment Qi.</p> <p>The Qi tensor is used in the regularization of the distribution functions. It is defined as Qi = cc - cs^2*I, where cc is the tensor of lattice velocities, cs is the speed of sound, and I is the identity tensor.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def construct_symmetric_lattice_moment(self):\n    \"\"\"\n    Construct the symmetric lattice moment Qi.\n\n    The Qi tensor is used in the regularization of the distribution functions. It is defined as Qi = cc - cs^2*I,\n    where cc is the tensor of lattice velocities, cs is the speed of sound, and I is the identity tensor.\n    \"\"\"\n    Qi = self.lattice.cc\n    if self.dim == 3:\n        diagonal = (0, 3, 5)\n        offdiagonal = (1, 2, 4)\n    elif self.dim == 2:\n        diagonal = (0, 2)\n        offdiagonal = (1,)\n    else:\n        raise ValueError(f\"dim = {self.dim} not supported\")\n\n    # Qi = cc - cs^2*I\n    Qi = Qi.at[:, diagonal].set(self.lattice.cc[:, diagonal] - 1./3.)\n\n    # multiply off-diagonal elements by 2 because the Q tensor is symmetric\n    Qi = Qi.at[:, offdiagonal].set(self.lattice.cc[:, offdiagonal] * 2.0)\n\n    self.Qi = Qi.T\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.regularize_fpop","title":"regularize_fpop","text":"<pre><code>regularize_fpop(fpop, feq)\n</code></pre> <p>Regularizes the distribution functions by adding non-equilibrium contributions based on second moments of fpop.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.regularize_fpop--parameters","title":"Parameters","text":"<p>fpop : jax.numpy.ndarray     The distribution functions. feq : jax.numpy.ndarray     The equilibrium distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.regularize_fpop--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The regularized distribution functions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef regularize_fpop(self, fpop, feq):\n    \"\"\"\n    Regularizes the distribution functions by adding non-equilibrium contributions based on second moments of fpop.\n\n    Parameters\n    ----------\n    fpop : jax.numpy.ndarray\n        The distribution functions.\n    feq : jax.numpy.ndarray\n        The equilibrium distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The regularized distribution functions.\n    \"\"\"\n\n    # Compute momentum flux of off-equilibrium populations for regularization: Pi^1 = Pi^{neq}\n    f_neq = fpop - feq\n    PiNeq = self.momentum_flux(f_neq)\n    # PiNeq = self.momentum_flux(fpop) - self.momentum_flux(feq)\n\n    # Compute double dot product Qi:Pi1\n    # QiPi1 = np.zeros_like(fpop)\n    # Pi1 = PiNeq\n    # QiPi1 = jnp.dot(Qi, Pi1)\n    QiPi1 = jnp.dot(PiNeq, self.Qi)\n\n    # assign all populations based on eq 45 of Latt et al (2008)\n    # fneq ~ f^1\n    fpop1 = 9. / 2. * self.lattice.w[None, :] * QiPi1\n    fpop_regularized = feq + fpop1\n\n    return fpop_regularized\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cExtrapolationOutflow\u201d. sound_speed : float     The speed of sound in the simulation.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow--references","title":"References","text":"<p>Geier, M., Sch\u00f6nherr, M., Pasquali, A., &amp; Krafczyk, M. (2015). The cumulant lattice Boltzmann equation in three dimensions: Theory and validation. Computers &amp; Mathematics with Applications, 70(4), 507\u2013547. doi:10.1016/j.camwa.2015.05.001.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class ExtrapolationOutflow(BoundaryCondition):\n    \"\"\"\n    Extrapolation outflow boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements the extrapolation outflow boundary condition, which is a type of outflow boundary condition\n    that uses extrapolation to avoid strong wave reflections.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"ExtrapolationOutflow\".\n    sound_speed : float\n        The speed of sound in the simulation.\n\n    References\n    ----------\n    Geier, M., Sch\u00f6nherr, M., Pasquali, A., &amp; Krafczyk, M. (2015). The cumulant lattice Boltzmann equation in three\n    dimensions: Theory and validation. Computers &amp; Mathematics with Applications, 70(4), 507\u2013547.\n    doi:10.1016/j.camwa.2015.05.001.\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"ExtrapolationOutflow\"\n        self.needsExtraConfiguration = True\n        self.sound_speed = 1./jnp.sqrt(3.)\n\n    def configure(self, boundaryMask):\n        \"\"\"\n        Configure the boundary condition by finding neighbouring voxel indices.\n\n        Parameters\n        ----------\n        boundaryMask : np.ndarray\n            The grid mask for the boundary voxels.\n        \"\"\"        \n        hasFluidNeighbour = ~boundaryMask[:, self.lattice.opp_indices]\n        idx = np.array(self.indices).T\n        idx_trg = []\n        for i in range(self.lattice.q):\n            idx_trg.append(idx[hasFluidNeighbour[:, i], :] + self.lattice.c[:, i])\n        indices_nbr = np.unique(np.vstack(idx_trg), axis=0)\n        self.indices_nbr = tuple(indices_nbr.T)\n\n        return\n\n    @partial(jit, static_argnums=(0, 3), inline=True)\n    def prepare_populations(self, fout, fin, implementation_step):\n        \"\"\"\n        Prepares the distribution functions for the boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The incoming distribution functions.\n        fin : jax.numpy.ndarray\n            The outgoing distribution functions.\n        implementation_step : str\n            The step in the lattice Boltzmann method algorithm at which the preparation is applied.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The prepared distribution functions.\n\n        Notes\n        -----\n        Because this function is called \"PostCollision\", f_poststreaming refers to previous time step or t-1\n        \"\"\"\n        f_postcollision = fout\n        f_poststreaming = fin\n        if implementation_step == 'PostStreaming':\n            return f_postcollision\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        fps_bdr = f_poststreaming[self.indices]\n        fps_nbr = f_poststreaming[self.indices_nbr]\n        fpc_bdr = f_postcollision[self.indices]\n        fpop = fps_bdr[bindex, self.imissing]\n        fpop_neighbour = fps_nbr[bindex, self.imissing]\n        fpop_extrapolated = self.sound_speed * fpop_neighbour + (1. - self.sound_speed) * fpop\n\n        # Use the iknown directions of f_postcollision that leave the domain during streaming to store the BC data\n        fpc_bdr = fpc_bdr.at[bindex, self.iknown].set(fpop_extrapolated)\n        f_postcollision = f_postcollision.at[self.indices].set(fpc_bdr)\n        return f_postcollision\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the extrapolation outflow boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n        \"\"\"\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        fbd = fout[self.indices]\n        fbd = fbd.at[bindex, self.imissing].set(fin[self.indices][bindex, self.iknown])\n        return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the extrapolation outflow boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the extrapolation outflow boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n    \"\"\"\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    fbd = fout[self.indices]\n    fbd = fbd.at[bindex, self.imissing].set(fin[self.indices][bindex, self.iknown])\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.configure","title":"configure","text":"<pre><code>configure(boundaryMask)\n</code></pre> <p>Configure the boundary condition by finding neighbouring voxel indices.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.configure--parameters","title":"Parameters","text":"<p>boundaryMask : np.ndarray     The grid mask for the boundary voxels.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def configure(self, boundaryMask):\n    \"\"\"\n    Configure the boundary condition by finding neighbouring voxel indices.\n\n    Parameters\n    ----------\n    boundaryMask : np.ndarray\n        The grid mask for the boundary voxels.\n    \"\"\"        \n    hasFluidNeighbour = ~boundaryMask[:, self.lattice.opp_indices]\n    idx = np.array(self.indices).T\n    idx_trg = []\n    for i in range(self.lattice.q):\n        idx_trg.append(idx[hasFluidNeighbour[:, i], :] + self.lattice.c[:, i])\n    indices_nbr = np.unique(np.vstack(idx_trg), axis=0)\n    self.indices_nbr = tuple(indices_nbr.T)\n\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.prepare_populations","title":"prepare_populations","text":"<pre><code>prepare_populations(fout, fin, implementation_step)\n</code></pre> <p>Prepares the distribution functions for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.prepare_populations--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The incoming distribution functions. fin : jax.numpy.ndarray     The outgoing distribution functions. implementation_step : str     The step in the lattice Boltzmann method algorithm at which the preparation is applied.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.prepare_populations--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The prepared distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.prepare_populations--notes","title":"Notes","text":"<p>Because this function is called \u201cPostCollision\u201d, f_poststreaming refers to previous time step or t-1</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), inline=True)\ndef prepare_populations(self, fout, fin, implementation_step):\n    \"\"\"\n    Prepares the distribution functions for the boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The incoming distribution functions.\n    fin : jax.numpy.ndarray\n        The outgoing distribution functions.\n    implementation_step : str\n        The step in the lattice Boltzmann method algorithm at which the preparation is applied.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The prepared distribution functions.\n\n    Notes\n    -----\n    Because this function is called \"PostCollision\", f_poststreaming refers to previous time step or t-1\n    \"\"\"\n    f_postcollision = fout\n    f_poststreaming = fin\n    if implementation_step == 'PostStreaming':\n        return f_postcollision\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    fps_bdr = f_poststreaming[self.indices]\n    fps_nbr = f_poststreaming[self.indices_nbr]\n    fpc_bdr = f_postcollision[self.indices]\n    fpop = fps_bdr[bindex, self.imissing]\n    fpop_neighbour = fps_nbr[bindex, self.imissing]\n    fpop_extrapolated = self.sound_speed * fpop_neighbour + (1. - self.sound_speed) * fpop\n\n    # Use the iknown directions of f_postcollision that leave the domain during streaming to store the BC data\n    fpc_bdr = fpc_bdr.at[bindex, self.iknown].set(fpop_extrapolated)\n    f_postcollision = f_postcollision.at[self.indices].set(fpc_bdr)\n    return f_postcollision\n</code></pre>"},{"location":"lattice/","title":"XLB lattice","text":"<p>               Bases: <code>object</code></p> <p>This class represents a lattice in the Lattice Boltzmann Method.</p> <p>It stores the properties of the lattice, including the dimensions, the number of  velocities, the velocity vectors, the weights, the moments, and the indices of the  opposite, main, right, and left velocities.</p> <p>The class also provides methods to construct these properties based on the name of the  lattice.</p> <p>               Bases: <code>Lattice</code></p> <p>Lattice class for 2D D2Q9 lattice.</p> <p>D2Q9 stands for two-dimensional nine-velocity model. It is a common model used in the  Lat tice Boltzmann Method for simulating fluid flows in two dimensions.</p> <p>               Bases: <code>Lattice</code></p> <p>Lattice class for 3D D3Q19 lattice.</p> <p>D3Q19 stands for three-dimensional nineteen-velocity model. It is a common model used in the  Lattice Boltzmann Method for simulating fluid flows in three dimensions.</p> <p>               Bases: <code>Lattice</code></p> <p>Lattice class for 3D D3Q27 lattice.</p> <p>D3Q27 stands for three-dimensional twenty-seven-velocity model. It is a common model used in the  Lattice Boltzmann Method for simulating fluid flows in three dimensions.</p>"},{"location":"lattice/#src.lattice.Lattice--parameters","title":"Parameters","text":"<p>name: str     The name of the lattice, which specifies the dimensions and the number of velocities.     For example, \u201cD2Q9\u201d represents a 2D lattice with 9 velocities. precision: str, optional     The precision of the computations. It can be \u201cf32/f32\u201d, \u201cf32/f16\u201d, \u201cf64/f64\u201d,      \u201cf64/f32\u201d, or \u201cf64/f16\u201d. The first part before the slash is the precision of the      computations, and the second part after the slash is the precision of the outputs.</p> Source code in <code>src/lattice.py</code> <pre><code>class Lattice(object):\n    \"\"\"\n    This class represents a lattice in the Lattice Boltzmann Method.\n\n    It stores the properties of the lattice, including the dimensions, the number of \n    velocities, the velocity vectors, the weights, the moments, and the indices of the \n    opposite, main, right, and left velocities.\n\n    The class also provides methods to construct these properties based on the name of the \n    lattice.\n\n    Parameters\n    ----------\n    name: str\n        The name of the lattice, which specifies the dimensions and the number of velocities.\n        For example, \"D2Q9\" represents a 2D lattice with 9 velocities.\n    precision: str, optional\n        The precision of the computations. It can be \"f32/f32\", \"f32/f16\", \"f64/f64\", \n        \"f64/f32\", or \"f64/f16\". The first part before the slash is the precision of the \n        computations, and the second part after the slash is the precision of the outputs.\n    \"\"\"\n    def __init__(self, name, precision=\"f32/f32\") -&gt; None:\n        self.name = name\n        dq = re.findall(r\"\\d+\", name)\n        self.precision = precision\n        self.d = int(dq[0])\n        self.q = int(dq[1])\n        if precision == \"f32/f32\" or precision == \"f32/f16\":\n            self.precisionPolicy = jnp.float32\n        elif precision == \"f64/f64\" or precision == \"f64/f32\" or precision == \"f64/f16\":\n            self.precisionPolicy = jnp.float64\n        elif precision == \"f16/f16\":\n            self.precisionPolicy = jnp.float16\n        else:\n            raise ValueError(\"precision not supported\")\n\n        # Construct the properties of the lattice\n        self.c = jnp.array(self.construct_lattice_velocity(), dtype=jnp.int8)\n        self.w = jnp.array(self.construct_lattice_weight(), dtype=self.precisionPolicy)\n        self.cc = jnp.array(self.construct_lattice_moment(), dtype=self.precisionPolicy)\n        self.opp_indices = jnp.array(self.construct_opposite_indices(), dtype=jnp.int8)\n        self.main_indices = jnp.array(self.construct_main_indices(), dtype=jnp.int8)\n        self.right_indices = np.array(self.construct_right_indices(), dtype=jnp.int8)\n        self.left_indices = np.array(self.construct_left_indices(), dtype=jnp.int8)\n\n    def construct_opposite_indices(self):\n        \"\"\"\n        This function constructs the indices of the opposite velocities for each velocity.\n\n        The opposite velocity of a velocity is the velocity that has the same magnitude but the \n        opposite direction.\n\n        Returns\n        -------\n        opposite: numpy.ndarray\n            The indices of the opposite velocities.\n        \"\"\"\n        c = self.c.T\n        opposite = np.array([c.tolist().index((-c[i]).tolist()) for i in range(self.q)])\n        return opposite\n\n    def construct_right_indices(self):\n        \"\"\"\n        This function constructs the indices of the velocities that point in the positive \n        x-direction.\n\n        Returns\n        -------\n        numpy.ndarray\n            The indices of the right velocities.\n        \"\"\"\n        c = self.c.T\n        return np.nonzero(c[:, 0] == 1)[0]\n\n    def construct_left_indices(self):\n        \"\"\"\n        This function constructs the indices of the velocities that point in the negative \n        x-direction.\n\n        Returns\n        -------\n        numpy.ndarray\n            The indices of the left velocities.\n        \"\"\"\n        c = self.c.T\n        return np.nonzero(c[:, 0] == -1)[0]\n\n    def construct_main_indices(self):\n        \"\"\"\n        This function constructs the indices of the main velocities.\n\n        The main velocities are the velocities that have a magnitude of 1 in lattice units.\n\n        Returns\n        -------\n        numpy.ndarray\n            The indices of the main velocities.\n        \"\"\"\n        c = self.c.T\n        if self.d == 2:\n            return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) == 1))[0]\n\n        elif self.d == 3:\n            return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) + np.abs(c[:, 2]) == 1))[0]\n\n    def construct_lattice_velocity(self):\n        \"\"\"\n        This function constructs the velocity vectors of the lattice.\n\n        The velocity vectors are defined based on the name of the lattice. For example, for a D2Q9 \n        lattice, there are 9 velocities: (0,0), (1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), \n        (1,-1), and (-1,1).\n\n        Returns\n        -------\n        c.T: numpy.ndarray\n            The velocity vectors of the lattice.\n        \"\"\"\n        if self.name == \"D2Q9\":  # D2Q9\n            cx = [0, 0, 0, 1, -1, 1, -1, 1, -1]\n            cy = [0, 1, -1, 0, 1, -1, 0, 1, -1]\n            c = np.array(tuple(zip(cx, cy)))\n        elif self.name == \"D3Q19\":  # D3Q19\n            c = [(x, y, z) for x in [0, -1, 1] for y in [0, -1, 1] for z in [0, -1, 1]]\n            c = np.array([ci for ci in c if np.linalg.norm(ci) &lt; 1.5])\n        elif self.name == \"D3Q27\":  # D3Q27\n            c = [(x, y, z) for x in [0, -1, 1] for y in [0, -1, 1] for z in [0, -1, 1]]\n            # c = np.array([ci for ci in c if np.linalg.norm(ci) &lt; 1.5])\n            c = np.array(c)\n        else:\n            raise ValueError(\"Supported Lattice types are D2Q9, D3Q19 and D3Q27\")\n\n        return c.T\n\n    def construct_lattice_weight(self):\n        \"\"\"\n        This function constructs the weights of the lattice.\n\n        The weights are defined based on the name of the lattice. For example, for a D2Q9 lattice, \n        the weights are 4/9 for the rest velocity, 1/9 for the main velocities, and 1/36 for the \n        diagonal velocities.\n\n        Returns\n        -------\n        w: numpy.ndarray\n            The weights of the lattice.\n        \"\"\"\n        # Get the transpose of the lattice vector\n        c = self.c.T\n\n        # Initialize the weights to be 1/36\n        w = 1.0 / 36.0 * np.ones(self.q)\n\n        # Update the weights for 2D and 3D lattices\n        if self.name == \"D2Q9\":\n            w[np.linalg.norm(c, axis=1) &lt; 1.1] = 1.0 / 9.0\n            w[0] = 4.0 / 9.0\n        elif self.name == \"D3Q19\":\n            w[np.linalg.norm(c, axis=1) &lt; 1.1] = 2.0 / 36.0\n            w[0] = 1.0 / 3.0\n        elif self.name == \"D3Q27\":\n            cl = np.linalg.norm(c, axis=1)\n            w[np.isclose(cl, 1.0, atol=1e-8)] = 2.0 / 27.0\n            w[(cl &gt; 1) &amp; (cl &lt;= np.sqrt(2))] = 1.0 / 54.0\n            w[(cl &gt; np.sqrt(2)) &amp; (cl &lt;= np.sqrt(3))] = 1.0 / 216.0\n            w[0] = 8.0 / 27.0\n        else:\n            raise ValueError(\"Supported Lattice types are D2Q9, D3Q19 and D3Q27\")\n\n        # Return the weights\n        return w\n\n    def construct_lattice_moment(self):\n        \"\"\"\n        This function constructs the moments of the lattice.\n\n        The moments are the products of the velocity vectors, which are used in the computation of \n        the equilibrium distribution functions and the collision operator in the Lattice Boltzmann \n        Method (LBM).\n\n        Returns\n        -------\n        cc: numpy.ndarray\n            The moments of the lattice.\n        \"\"\"\n        c = self.c.T\n        # Counter for the loop\n        cntr = 0\n\n        # nt: number of independent elements of a symmetric tensor\n        nt = self.d * (self.d + 1) // 2\n\n        cc = np.zeros((self.q, nt))\n        for a in range(0, self.d):\n            for b in range(a, self.d):\n                cc[:, cntr] = c[:, a] * c[:, b]\n                cntr += 1\n\n        return cc\n\n    def __str__(self):\n        return self.name\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_moment","title":"construct_lattice_moment","text":"<pre><code>construct_lattice_moment()\n</code></pre> <p>This function constructs the moments of the lattice.</p> <p>The moments are the products of the velocity vectors, which are used in the computation of  the equilibrium distribution functions and the collision operator in the Lattice Boltzmann  Method (LBM).</p>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_moment--returns","title":"Returns","text":"<p>cc: numpy.ndarray     The moments of the lattice.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_lattice_moment(self):\n    \"\"\"\n    This function constructs the moments of the lattice.\n\n    The moments are the products of the velocity vectors, which are used in the computation of \n    the equilibrium distribution functions and the collision operator in the Lattice Boltzmann \n    Method (LBM).\n\n    Returns\n    -------\n    cc: numpy.ndarray\n        The moments of the lattice.\n    \"\"\"\n    c = self.c.T\n    # Counter for the loop\n    cntr = 0\n\n    # nt: number of independent elements of a symmetric tensor\n    nt = self.d * (self.d + 1) // 2\n\n    cc = np.zeros((self.q, nt))\n    for a in range(0, self.d):\n        for b in range(a, self.d):\n            cc[:, cntr] = c[:, a] * c[:, b]\n            cntr += 1\n\n    return cc\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_velocity","title":"construct_lattice_velocity","text":"<pre><code>construct_lattice_velocity()\n</code></pre> <p>This function constructs the velocity vectors of the lattice.</p> <p>The velocity vectors are defined based on the name of the lattice. For example, for a D2Q9  lattice, there are 9 velocities: (0,0), (1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1),  (1,-1), and (-1,1).</p>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_velocity--returns","title":"Returns","text":"<p>c.T: numpy.ndarray     The velocity vectors of the lattice.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_lattice_velocity(self):\n    \"\"\"\n    This function constructs the velocity vectors of the lattice.\n\n    The velocity vectors are defined based on the name of the lattice. For example, for a D2Q9 \n    lattice, there are 9 velocities: (0,0), (1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), \n    (1,-1), and (-1,1).\n\n    Returns\n    -------\n    c.T: numpy.ndarray\n        The velocity vectors of the lattice.\n    \"\"\"\n    if self.name == \"D2Q9\":  # D2Q9\n        cx = [0, 0, 0, 1, -1, 1, -1, 1, -1]\n        cy = [0, 1, -1, 0, 1, -1, 0, 1, -1]\n        c = np.array(tuple(zip(cx, cy)))\n    elif self.name == \"D3Q19\":  # D3Q19\n        c = [(x, y, z) for x in [0, -1, 1] for y in [0, -1, 1] for z in [0, -1, 1]]\n        c = np.array([ci for ci in c if np.linalg.norm(ci) &lt; 1.5])\n    elif self.name == \"D3Q27\":  # D3Q27\n        c = [(x, y, z) for x in [0, -1, 1] for y in [0, -1, 1] for z in [0, -1, 1]]\n        # c = np.array([ci for ci in c if np.linalg.norm(ci) &lt; 1.5])\n        c = np.array(c)\n    else:\n        raise ValueError(\"Supported Lattice types are D2Q9, D3Q19 and D3Q27\")\n\n    return c.T\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_weight","title":"construct_lattice_weight","text":"<pre><code>construct_lattice_weight()\n</code></pre> <p>This function constructs the weights of the lattice.</p> <p>The weights are defined based on the name of the lattice. For example, for a D2Q9 lattice,  the weights are 4/9 for the rest velocity, 1/9 for the main velocities, and 1/36 for the  diagonal velocities.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_weight--returns","title":"Returns","text":"<p>w: numpy.ndarray     The weights of the lattice.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_lattice_weight(self):\n    \"\"\"\n    This function constructs the weights of the lattice.\n\n    The weights are defined based on the name of the lattice. For example, for a D2Q9 lattice, \n    the weights are 4/9 for the rest velocity, 1/9 for the main velocities, and 1/36 for the \n    diagonal velocities.\n\n    Returns\n    -------\n    w: numpy.ndarray\n        The weights of the lattice.\n    \"\"\"\n    # Get the transpose of the lattice vector\n    c = self.c.T\n\n    # Initialize the weights to be 1/36\n    w = 1.0 / 36.0 * np.ones(self.q)\n\n    # Update the weights for 2D and 3D lattices\n    if self.name == \"D2Q9\":\n        w[np.linalg.norm(c, axis=1) &lt; 1.1] = 1.0 / 9.0\n        w[0] = 4.0 / 9.0\n    elif self.name == \"D3Q19\":\n        w[np.linalg.norm(c, axis=1) &lt; 1.1] = 2.0 / 36.0\n        w[0] = 1.0 / 3.0\n    elif self.name == \"D3Q27\":\n        cl = np.linalg.norm(c, axis=1)\n        w[np.isclose(cl, 1.0, atol=1e-8)] = 2.0 / 27.0\n        w[(cl &gt; 1) &amp; (cl &lt;= np.sqrt(2))] = 1.0 / 54.0\n        w[(cl &gt; np.sqrt(2)) &amp; (cl &lt;= np.sqrt(3))] = 1.0 / 216.0\n        w[0] = 8.0 / 27.0\n    else:\n        raise ValueError(\"Supported Lattice types are D2Q9, D3Q19 and D3Q27\")\n\n    # Return the weights\n    return w\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_left_indices","title":"construct_left_indices","text":"<pre><code>construct_left_indices()\n</code></pre> <p>This function constructs the indices of the velocities that point in the negative  x-direction.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_left_indices--returns","title":"Returns","text":"<p>numpy.ndarray     The indices of the left velocities.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_left_indices(self):\n    \"\"\"\n    This function constructs the indices of the velocities that point in the negative \n    x-direction.\n\n    Returns\n    -------\n    numpy.ndarray\n        The indices of the left velocities.\n    \"\"\"\n    c = self.c.T\n    return np.nonzero(c[:, 0] == -1)[0]\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_main_indices","title":"construct_main_indices","text":"<pre><code>construct_main_indices()\n</code></pre> <p>This function constructs the indices of the main velocities.</p> <p>The main velocities are the velocities that have a magnitude of 1 in lattice units.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_main_indices--returns","title":"Returns","text":"<p>numpy.ndarray     The indices of the main velocities.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_main_indices(self):\n    \"\"\"\n    This function constructs the indices of the main velocities.\n\n    The main velocities are the velocities that have a magnitude of 1 in lattice units.\n\n    Returns\n    -------\n    numpy.ndarray\n        The indices of the main velocities.\n    \"\"\"\n    c = self.c.T\n    if self.d == 2:\n        return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) == 1))[0]\n\n    elif self.d == 3:\n        return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) + np.abs(c[:, 2]) == 1))[0]\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_opposite_indices","title":"construct_opposite_indices","text":"<pre><code>construct_opposite_indices()\n</code></pre> <p>This function constructs the indices of the opposite velocities for each velocity.</p> <p>The opposite velocity of a velocity is the velocity that has the same magnitude but the  opposite direction.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_opposite_indices--returns","title":"Returns","text":"<p>opposite: numpy.ndarray     The indices of the opposite velocities.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_opposite_indices(self):\n    \"\"\"\n    This function constructs the indices of the opposite velocities for each velocity.\n\n    The opposite velocity of a velocity is the velocity that has the same magnitude but the \n    opposite direction.\n\n    Returns\n    -------\n    opposite: numpy.ndarray\n        The indices of the opposite velocities.\n    \"\"\"\n    c = self.c.T\n    opposite = np.array([c.tolist().index((-c[i]).tolist()) for i in range(self.q)])\n    return opposite\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_right_indices","title":"construct_right_indices","text":"<pre><code>construct_right_indices()\n</code></pre> <p>This function constructs the indices of the velocities that point in the positive  x-direction.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_right_indices--returns","title":"Returns","text":"<p>numpy.ndarray     The indices of the right velocities.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_right_indices(self):\n    \"\"\"\n    This function constructs the indices of the velocities that point in the positive \n    x-direction.\n\n    Returns\n    -------\n    numpy.ndarray\n        The indices of the right velocities.\n    \"\"\"\n    c = self.c.T\n    return np.nonzero(c[:, 0] == 1)[0]\n</code></pre>"},{"location":"lattice/#src.lattice.LatticeD2Q9--parameters","title":"Parameters","text":"<p>precision: str, optional     The precision of the lattice. The default is \u201cf32/f32\u201d</p> Source code in <code>src/lattice.py</code> <pre><code>class LatticeD2Q9(Lattice):\n    \"\"\"\n    Lattice class for 2D D2Q9 lattice.\n\n    D2Q9 stands for two-dimensional nine-velocity model. It is a common model used in the \n    Lat tice Boltzmann Method for simulating fluid flows in two dimensions.\n\n    Parameters\n    ----------\n    precision: str, optional\n        The precision of the lattice. The default is \"f32/f32\"\n    \"\"\"\n    def __init__(self, precision=\"f32/f32\"):\n        super().__init__(\"D2Q9\", precision)\n        self._set_constants()\n\n    def _set_constants(self):\n        self.cs = jnp.sqrt(3) / 3.0\n        self.cs2 = 1.0 / 3.0\n        self.inv_cs2 = 3.0\n        self.i_s = jnp.asarray(list(range(9)))\n        self.im = 3  # Number of imiddles (includes center)\n        self.ik = 3  # Number of iknowns or iunknowns\n</code></pre>"},{"location":"lattice/#src.lattice.LatticeD3Q19--parameters","title":"Parameters","text":"<p>precision: str, optional     The precision of the lattice. The default is \u201cf32/f32\u201d</p> Source code in <code>src/lattice.py</code> <pre><code>class LatticeD3Q19(Lattice):\n    \"\"\"\n    Lattice class for 3D D3Q19 lattice.\n\n    D3Q19 stands for three-dimensional nineteen-velocity model. It is a common model used in the \n    Lattice Boltzmann Method for simulating fluid flows in three dimensions.\n\n    Parameters\n    ----------\n    precision: str, optional\n        The precision of the lattice. The default is \"f32/f32\"\n    \"\"\"\n    def __init__(self, precision=\"f32/f32\"):\n        super().__init__(\"D3Q19\", precision)\n        self._set_constants()\n\n    def _set_constants(self):\n        self.cs = jnp.sqrt(3) / 3.0\n        self.cs2 = 1.0 / 3.0\n        self.inv_cs2 = 3.0\n        self.i_s = jnp.asarray(list(range(19)), dtype=jnp.int8)\n\n        self.im = 9  # Number of imiddles (includes center)\n        self.ik = 5  # Number of iknowns or iunknowns\n</code></pre>"},{"location":"lattice/#src.lattice.LatticeD3Q27--parameters","title":"Parameters","text":"<p>precision: str, optional     The precision of the lattice. The default is \u201cf32/f32\u201d</p> Source code in <code>src/lattice.py</code> <pre><code>class LatticeD3Q27(Lattice):\n    \"\"\"\n    Lattice class for 3D D3Q27 lattice.\n\n    D3Q27 stands for three-dimensional twenty-seven-velocity model. It is a common model used in the \n    Lattice Boltzmann Method for simulating fluid flows in three dimensions.\n\n    Parameters\n    ----------\n    precision: str, optional\n        The precision of the lattice. The default is \"f32/f32\"\n    \"\"\"\n\n    def __init__(self, precision=\"f32/f32\"):\n        super().__init__(\"D3Q27\", precision)\n        self._set_constants()\n\n    def _set_constants(self):\n        self.cs = jnp.sqrt(3) / 3.0\n        self.cs2 = 1.0 / 3.0\n        self.inv_cs2 = 3.0\n        self.i_s = jnp.asarray(list(range(27)), dtype=jnp.int8)\n</code></pre>"},{"location":"models/","title":"XLB models","text":"<p>               Bases: <code>LBMBase</code></p> <p>BGK simulation class.</p> <p>This class implements the Bhatnagar-Gross-Krook (BGK) approximation for the collision step in the Lattice Boltzmann Method.</p> Source code in <code>src/models.py</code> <pre><code>class BGKSim(LBMBase):\n    \"\"\"\n    BGK simulation class.\n\n    This class implements the Bhatnagar-Gross-Krook (BGK) approximation for the collision step in the Lattice Boltzmann Method.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, f):\n        \"\"\"\n        BGK collision step for lattice.\n\n        The collision step is where the main physics of the LBM is applied. In the BGK approximation, \n        the distribution function is relaxed towards the equilibrium distribution function.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        print(\"shape of distribution function is: {}\".format(f.shape))\n        print(\"type of f is: {}\".format(type(f)))\n        rho, u = self.update_macroscopic(f)\n        feq = self.equilibrium(rho, u, cast_output=False)\n        fneq = f - feq\n        fout = f - self.omega * fneq\n        if self.force is not None:\n            fout = self.apply_force(fout, feq, rho, u)\n        return self.precisionPolicy.cast_to_output(fout)\n</code></pre> <p>               Bases: <code>LBMBase</code></p> <p>KBC simulation class.</p> <p>This class implements the Karlin-B\u00f6sch-Chikatamarla (KBC) model for the collision step in the Lattice Boltzmann Method.</p> Source code in <code>src/models.py</code> <pre><code>class KBCSim(LBMBase):\n    \"\"\"\n    KBC simulation class.\n\n    This class implements the Karlin-B\u00f6sch-Chikatamarla (KBC) model for the collision step in the Lattice Boltzmann Method.\n    \"\"\"\n    def __init__(self, **kwargs):\n        if kwargs.get('lattice').name != 'D3Q27' and kwargs.get('nz') &gt; 0:\n            raise ValueError(\"KBC collision operator in 3D must only be used with D3Q27 lattice.\")\n        super().__init__(**kwargs)\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, f):\n        \"\"\"\n        KBC collision step for lattice.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        tiny = 1e-32\n        beta = self.omega * 0.5\n        rho, u = self.update_macroscopic(f)\n        feq = self.equilibrium(rho, u, cast_output=False)\n        fneq = f - feq\n        if self.dim == 2:\n            deltaS = self.fdecompose_shear_d2q9(fneq) * rho / 4.0\n        else:\n            deltaS = self.fdecompose_shear_d3q27(fneq) * rho\n        deltaH = fneq - deltaS\n        invBeta = 1.0 / beta\n        gamma = invBeta - (2.0 - invBeta) * self.entropic_scalar_product(deltaS, deltaH, feq) / (tiny + self.entropic_scalar_product(deltaH, deltaH, feq))\n\n        fout = f - beta * (2.0 * deltaS + gamma[..., None] * deltaH)\n\n        # add external force\n        if self.force is not None:\n            fout = self.apply_force(fout, feq, rho, u)\n        return self.precisionPolicy.cast_to_output(fout)\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision_modified(self, f):\n        \"\"\"\n        Alternative KBC collision step for lattice.\n        Note: \n        At low Reynolds number the orignal KBC collision above produces inaccurate results because\n        it does not check for the entropy increase/decrease. The KBC stabalizations should only be \n        applied in principle to cells whose entropy decrease after a regular BGK collision. This is \n        the case in most cells at higher Reynolds numbers and hence a check may not be needed. \n        Overall the following alternative collision is more reliable and may replace the original \n        implementation. The issue at the moment is that it is about 60-80% slower than the above method.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        tiny = 1e-32\n        beta = self.omega * 0.5\n        rho, u = self.update_macroscopic(f)\n        feq = self.equilibrium(rho, u, castOutput=False)\n\n        # Alternative KBC: only stabalizes for voxels whose entropy decreases after BGK collision.\n        f_bgk = f - self.omega * (f - feq)\n        H_fin = jnp.sum(f * jnp.log(f / self.w), axis=-1, keepdims=True)\n        H_fout = jnp.sum(f_bgk * jnp.log(f_bgk / self.w), axis=-1, keepdims=True)\n\n        # the rest is identical to collision_deprecated\n        fneq = f - feq\n        if self.dim == 2:\n            deltaS = self.fdecompose_shear_d2q9(fneq) * rho / 4.0\n        else:\n            deltaS = self.fdecompose_shear_d3q27(fneq) * rho\n        deltaH = fneq - deltaS\n        invBeta = 1.0 / beta\n        gamma = invBeta - (2.0 - invBeta) * self.entropic_scalar_product(deltaS, deltaH, feq) / (tiny + self.entropic_scalar_product(deltaH, deltaH, feq))\n\n        f_kbc = f - beta * (2.0 * deltaS + gamma[..., None] * deltaH)\n        fout = jnp.where(H_fout &gt; H_fin, f_kbc, f_bgk)\n\n        # add external force\n        if self.force is not None:\n            fout = self.apply_force(fout, feq, rho, u)\n        return self.precisionPolicy.cast_to_output(fout)\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def entropic_scalar_product(self, x, y, feq):\n        \"\"\"\n        Compute the entropic scalar product of x and y to approximate gamma in KBC.\n\n        Returns\n        -------\n        jax.numpy.array\n            Entropic scalar product of x, y, and feq.\n        \"\"\"\n        return jnp.sum(x * y / feq, axis=-1)\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def fdecompose_shear_d2q9(self, fneq):\n        \"\"\"\n        Decompose fneq into shear components for D2Q9 lattice.\n\n        Parameters\n        ----------\n        fneq : jax.numpy.array\n            Non-equilibrium distribution function.\n\n        Returns\n        -------\n        jax.numpy.array\n            Shear components of fneq.\n        \"\"\"\n        Pi = self.momentum_flux(fneq)\n        N = Pi[..., 0] - Pi[..., 2]\n        s = jnp.zeros_like(fneq)\n        s = s.at[..., 6].set(N)\n        s = s.at[..., 3].set(N)\n        s = s.at[..., 2].set(-N)\n        s = s.at[..., 1].set(-N)\n        s = s.at[..., 8].set(Pi[..., 1])\n        s = s.at[..., 4].set(-Pi[..., 1])\n        s = s.at[..., 5].set(-Pi[..., 1])\n        s = s.at[..., 7].set(Pi[..., 1])\n\n        return s\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def fdecompose_shear_d3q27(self, fneq):\n        \"\"\"\n        Decompose fneq into shear components for D3Q27 lattice.\n\n        Parameters\n        ----------\n        fneq : jax.numpy.ndarray\n            Non-equilibrium distribution function.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            Shear components of fneq.\n        \"\"\"\n        # if self.grid.dim == 3:\n        #     diagonal    = (0, 3, 5)\n        #     offdiagonal = (1, 2, 4)\n        # elif self.grid.dim == 2:\n        #     diagonal    = (0, 2)\n        #     offdiagonal = (1,)\n\n        # c=\n        # array([[0, 0, 0],-----0\n        #        [0, 0, -1],----1\n        #        [0, 0, 1],-----2\n        #        [0, -1, 0],----3\n        #        [0, -1, -1],---4\n        #        [0, -1, 1],----5\n        #        [0, 1, 0],-----6\n        #        [0, 1, -1],----7\n        #        [0, 1, 1],-----8\n        #        [-1, 0, 0],----9\n        #        [-1, 0, -1],--10\n        #        [-1, 0, 1],---11\n        #        [-1, -1, 0],--12\n        #        [-1, -1, -1],-13\n        #        [-1, -1, 1],--14\n        #        [-1, 1, 0],---15\n        #        [-1, 1, -1],--16\n        #        [-1, 1, 1],---17\n        #        [1, 0, 0],----18\n        #        [1, 0, -1],---19\n        #        [1, 0, 1],----20\n        #        [1, -1, 0],---21\n        #        [1, -1, -1],--22\n        #        [1, -1, 1],---23\n        #        [1, 1, 0],----24\n        #        [1, 1, -1],---25\n        #        [1, 1, 1]])---26\n        Pi = self.momentum_flux(fneq)\n        Nxz = Pi[..., 0] - Pi[..., 5]\n        Nyz = Pi[..., 3] - Pi[..., 5]\n\n        # For c = (i, 0, 0), c = (0, j, 0) and c = (0, 0, k)\n        s = jnp.zeros_like(fneq)\n        s = s.at[..., 9].set((2.0 * Nxz - Nyz) / 6.0)\n        s = s.at[..., 18].set((2.0 * Nxz - Nyz) / 6.0)\n        s = s.at[..., 3].set((-Nxz + 2.0 * Nyz) / 6.0)\n        s = s.at[..., 6].set((-Nxz + 2.0 * Nyz) / 6.0)\n        s = s.at[..., 1].set((-Nxz - Nyz) / 6.0)\n        s = s.at[..., 2].set((-Nxz - Nyz) / 6.0)\n\n        # For c = (i, j, 0)\n        s = s.at[..., 12].set(Pi[..., 1] / 4.0)\n        s = s.at[..., 24].set(Pi[..., 1] / 4.0)\n        s = s.at[..., 21].set(-Pi[..., 1] / 4.0)\n        s = s.at[..., 15].set(-Pi[..., 1] / 4.0)\n\n        # For c = (i, 0, k)\n        s = s.at[..., 10].set(Pi[..., 2] / 4.0)\n        s = s.at[..., 20].set(Pi[..., 2] / 4.0)\n        s = s.at[..., 19].set(-Pi[..., 2] / 4.0)\n        s = s.at[..., 11].set(-Pi[..., 2] / 4.0)\n\n        # For c = (0, j, k)\n        s = s.at[..., 8].set(Pi[..., 4] / 4.0)\n        s = s.at[..., 4].set(Pi[..., 4] / 4.0)\n        s = s.at[..., 7].set(-Pi[..., 4] / 4.0)\n        s = s.at[..., 5].set(-Pi[..., 4] / 4.0)\n\n        return s\n</code></pre> <p>               Bases: <code>LBMBase</code></p> <p>Advection Diffusion Model based on the BGK model.</p> Source code in <code>src/models.py</code> <pre><code>class AdvectionDiffusionBGK(LBMBase):\n    \"\"\"\n    Advection Diffusion Model based on the BGK model.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.vel = kwargs.get(\"vel\", None)\n        if self.vel is None:\n            raise ValueError(\"Velocity must be specified for AdvectionDiffusionBGK.\")\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, f):\n        \"\"\"\n        BGK collision step for lattice.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        rho =jnp.sum(f, axis=-1, keepdims=True)\n        feq = self.equilibrium(rho, self.vel, cast_output=False)\n        fneq = f - feq\n        fout = f - self.omega * fneq\n        return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.BGKSim.collision","title":"collision","text":"<pre><code>collision(f)\n</code></pre> <p>BGK collision step for lattice.</p> <p>The collision step is where the main physics of the LBM is applied. In the BGK approximation,  the distribution function is relaxed towards the equilibrium distribution function.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, f):\n    \"\"\"\n    BGK collision step for lattice.\n\n    The collision step is where the main physics of the LBM is applied. In the BGK approximation, \n    the distribution function is relaxed towards the equilibrium distribution function.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    print(\"shape of distribution function is: {}\".format(f.shape))\n    print(\"type of f is: {}\".format(type(f)))\n    rho, u = self.update_macroscopic(f)\n    feq = self.equilibrium(rho, u, cast_output=False)\n    fneq = f - feq\n    fout = f - self.omega * fneq\n    if self.force is not None:\n        fout = self.apply_force(fout, feq, rho, u)\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.KBCSim.collision","title":"collision","text":"<pre><code>collision(f)\n</code></pre> <p>KBC collision step for lattice.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, f):\n    \"\"\"\n    KBC collision step for lattice.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    tiny = 1e-32\n    beta = self.omega * 0.5\n    rho, u = self.update_macroscopic(f)\n    feq = self.equilibrium(rho, u, cast_output=False)\n    fneq = f - feq\n    if self.dim == 2:\n        deltaS = self.fdecompose_shear_d2q9(fneq) * rho / 4.0\n    else:\n        deltaS = self.fdecompose_shear_d3q27(fneq) * rho\n    deltaH = fneq - deltaS\n    invBeta = 1.0 / beta\n    gamma = invBeta - (2.0 - invBeta) * self.entropic_scalar_product(deltaS, deltaH, feq) / (tiny + self.entropic_scalar_product(deltaH, deltaH, feq))\n\n    fout = f - beta * (2.0 * deltaS + gamma[..., None] * deltaH)\n\n    # add external force\n    if self.force is not None:\n        fout = self.apply_force(fout, feq, rho, u)\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.KBCSim.collision_modified","title":"collision_modified","text":"<pre><code>collision_modified(f)\n</code></pre> <p>Alternative KBC collision step for lattice. Note:  At low Reynolds number the orignal KBC collision above produces inaccurate results because it does not check for the entropy increase/decrease. The KBC stabalizations should only be  applied in principle to cells whose entropy decrease after a regular BGK collision. This is  the case in most cells at higher Reynolds numbers and hence a check may not be needed.  Overall the following alternative collision is more reliable and may replace the original  implementation. The issue at the moment is that it is about 60-80% slower than the above method.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision_modified(self, f):\n    \"\"\"\n    Alternative KBC collision step for lattice.\n    Note: \n    At low Reynolds number the orignal KBC collision above produces inaccurate results because\n    it does not check for the entropy increase/decrease. The KBC stabalizations should only be \n    applied in principle to cells whose entropy decrease after a regular BGK collision. This is \n    the case in most cells at higher Reynolds numbers and hence a check may not be needed. \n    Overall the following alternative collision is more reliable and may replace the original \n    implementation. The issue at the moment is that it is about 60-80% slower than the above method.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    tiny = 1e-32\n    beta = self.omega * 0.5\n    rho, u = self.update_macroscopic(f)\n    feq = self.equilibrium(rho, u, castOutput=False)\n\n    # Alternative KBC: only stabalizes for voxels whose entropy decreases after BGK collision.\n    f_bgk = f - self.omega * (f - feq)\n    H_fin = jnp.sum(f * jnp.log(f / self.w), axis=-1, keepdims=True)\n    H_fout = jnp.sum(f_bgk * jnp.log(f_bgk / self.w), axis=-1, keepdims=True)\n\n    # the rest is identical to collision_deprecated\n    fneq = f - feq\n    if self.dim == 2:\n        deltaS = self.fdecompose_shear_d2q9(fneq) * rho / 4.0\n    else:\n        deltaS = self.fdecompose_shear_d3q27(fneq) * rho\n    deltaH = fneq - deltaS\n    invBeta = 1.0 / beta\n    gamma = invBeta - (2.0 - invBeta) * self.entropic_scalar_product(deltaS, deltaH, feq) / (tiny + self.entropic_scalar_product(deltaH, deltaH, feq))\n\n    f_kbc = f - beta * (2.0 * deltaS + gamma[..., None] * deltaH)\n    fout = jnp.where(H_fout &gt; H_fin, f_kbc, f_bgk)\n\n    # add external force\n    if self.force is not None:\n        fout = self.apply_force(fout, feq, rho, u)\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.KBCSim.entropic_scalar_product","title":"entropic_scalar_product","text":"<pre><code>entropic_scalar_product(x, y, feq)\n</code></pre> <p>Compute the entropic scalar product of x and y to approximate gamma in KBC.</p>"},{"location":"models/#src.models.KBCSim.entropic_scalar_product--returns","title":"Returns","text":"<p>jax.numpy.array     Entropic scalar product of x, y, and feq.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef entropic_scalar_product(self, x, y, feq):\n    \"\"\"\n    Compute the entropic scalar product of x and y to approximate gamma in KBC.\n\n    Returns\n    -------\n    jax.numpy.array\n        Entropic scalar product of x, y, and feq.\n    \"\"\"\n    return jnp.sum(x * y / feq, axis=-1)\n</code></pre>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d2q9","title":"fdecompose_shear_d2q9","text":"<pre><code>fdecompose_shear_d2q9(fneq)\n</code></pre> <p>Decompose fneq into shear components for D2Q9 lattice.</p>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d2q9--parameters","title":"Parameters","text":"<p>fneq : jax.numpy.array     Non-equilibrium distribution function.</p>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d2q9--returns","title":"Returns","text":"<p>jax.numpy.array     Shear components of fneq.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef fdecompose_shear_d2q9(self, fneq):\n    \"\"\"\n    Decompose fneq into shear components for D2Q9 lattice.\n\n    Parameters\n    ----------\n    fneq : jax.numpy.array\n        Non-equilibrium distribution function.\n\n    Returns\n    -------\n    jax.numpy.array\n        Shear components of fneq.\n    \"\"\"\n    Pi = self.momentum_flux(fneq)\n    N = Pi[..., 0] - Pi[..., 2]\n    s = jnp.zeros_like(fneq)\n    s = s.at[..., 6].set(N)\n    s = s.at[..., 3].set(N)\n    s = s.at[..., 2].set(-N)\n    s = s.at[..., 1].set(-N)\n    s = s.at[..., 8].set(Pi[..., 1])\n    s = s.at[..., 4].set(-Pi[..., 1])\n    s = s.at[..., 5].set(-Pi[..., 1])\n    s = s.at[..., 7].set(Pi[..., 1])\n\n    return s\n</code></pre>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d3q27","title":"fdecompose_shear_d3q27","text":"<pre><code>fdecompose_shear_d3q27(fneq)\n</code></pre> <p>Decompose fneq into shear components for D3Q27 lattice.</p>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d3q27--parameters","title":"Parameters","text":"<p>fneq : jax.numpy.ndarray     Non-equilibrium distribution function.</p>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d3q27--returns","title":"Returns","text":"<p>jax.numpy.ndarray     Shear components of fneq.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef fdecompose_shear_d3q27(self, fneq):\n    \"\"\"\n    Decompose fneq into shear components for D3Q27 lattice.\n\n    Parameters\n    ----------\n    fneq : jax.numpy.ndarray\n        Non-equilibrium distribution function.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        Shear components of fneq.\n    \"\"\"\n    # if self.grid.dim == 3:\n    #     diagonal    = (0, 3, 5)\n    #     offdiagonal = (1, 2, 4)\n    # elif self.grid.dim == 2:\n    #     diagonal    = (0, 2)\n    #     offdiagonal = (1,)\n\n    # c=\n    # array([[0, 0, 0],-----0\n    #        [0, 0, -1],----1\n    #        [0, 0, 1],-----2\n    #        [0, -1, 0],----3\n    #        [0, -1, -1],---4\n    #        [0, -1, 1],----5\n    #        [0, 1, 0],-----6\n    #        [0, 1, -1],----7\n    #        [0, 1, 1],-----8\n    #        [-1, 0, 0],----9\n    #        [-1, 0, -1],--10\n    #        [-1, 0, 1],---11\n    #        [-1, -1, 0],--12\n    #        [-1, -1, -1],-13\n    #        [-1, -1, 1],--14\n    #        [-1, 1, 0],---15\n    #        [-1, 1, -1],--16\n    #        [-1, 1, 1],---17\n    #        [1, 0, 0],----18\n    #        [1, 0, -1],---19\n    #        [1, 0, 1],----20\n    #        [1, -1, 0],---21\n    #        [1, -1, -1],--22\n    #        [1, -1, 1],---23\n    #        [1, 1, 0],----24\n    #        [1, 1, -1],---25\n    #        [1, 1, 1]])---26\n    Pi = self.momentum_flux(fneq)\n    Nxz = Pi[..., 0] - Pi[..., 5]\n    Nyz = Pi[..., 3] - Pi[..., 5]\n\n    # For c = (i, 0, 0), c = (0, j, 0) and c = (0, 0, k)\n    s = jnp.zeros_like(fneq)\n    s = s.at[..., 9].set((2.0 * Nxz - Nyz) / 6.0)\n    s = s.at[..., 18].set((2.0 * Nxz - Nyz) / 6.0)\n    s = s.at[..., 3].set((-Nxz + 2.0 * Nyz) / 6.0)\n    s = s.at[..., 6].set((-Nxz + 2.0 * Nyz) / 6.0)\n    s = s.at[..., 1].set((-Nxz - Nyz) / 6.0)\n    s = s.at[..., 2].set((-Nxz - Nyz) / 6.0)\n\n    # For c = (i, j, 0)\n    s = s.at[..., 12].set(Pi[..., 1] / 4.0)\n    s = s.at[..., 24].set(Pi[..., 1] / 4.0)\n    s = s.at[..., 21].set(-Pi[..., 1] / 4.0)\n    s = s.at[..., 15].set(-Pi[..., 1] / 4.0)\n\n    # For c = (i, 0, k)\n    s = s.at[..., 10].set(Pi[..., 2] / 4.0)\n    s = s.at[..., 20].set(Pi[..., 2] / 4.0)\n    s = s.at[..., 19].set(-Pi[..., 2] / 4.0)\n    s = s.at[..., 11].set(-Pi[..., 2] / 4.0)\n\n    # For c = (0, j, k)\n    s = s.at[..., 8].set(Pi[..., 4] / 4.0)\n    s = s.at[..., 4].set(Pi[..., 4] / 4.0)\n    s = s.at[..., 7].set(-Pi[..., 4] / 4.0)\n    s = s.at[..., 5].set(-Pi[..., 4] / 4.0)\n\n    return s\n</code></pre>"},{"location":"models/#src.models.AdvectionDiffusionBGK.collision","title":"collision","text":"<pre><code>collision(f)\n</code></pre> <p>BGK collision step for lattice.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, f):\n    \"\"\"\n    BGK collision step for lattice.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    rho =jnp.sum(f, axis=-1, keepdims=True)\n    feq = self.equilibrium(rho, self.vel, cast_output=False)\n    fneq = f - feq\n    fout = f - self.omega * fneq\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"utils/","title":"XLB utils","text":"<p>Downsample a JAX array by a factor of <code>factor</code> along each axis.</p> <p>Save an image of a field at a given timestep.</p> <p>Save VTK fields to the specified directory.</p> <p>Live rendering of a 3D volume using pyvista.</p> <p>Save boundary conditions as VTK format to the specified directory.</p> <p>Rotates a voxelized mesh around a given axis.</p> <p>Converts an STL file to a voxelized mesh.</p>"},{"location":"utils/#src.utils.downsample_field--parameters","title":"Parameters","text":"<p>field : jax.numpy.ndarray     The input vector field to be downsampled. This should be a 3D or 4D JAX array where the last dimension is 2 or 3 (vector components). factor : int     The factor by which to downsample the field. The dimensions of the field will be divided by this factor. method : str, optional     The method to use for downsampling. Default is \u2018bicubic\u2019.</p>"},{"location":"utils/#src.utils.downsample_field--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The downsampled field.</p> Source code in <code>src/utils.py</code> <pre><code>@partial(jit, static_argnums=(1, 2))\ndef downsample_field(field, factor, method='bicubic'):\n    \"\"\"\n    Downsample a JAX array by a factor of `factor` along each axis.\n\n    Parameters\n    ----------\n    field : jax.numpy.ndarray\n        The input vector field to be downsampled. This should be a 3D or 4D JAX array where the last dimension is 2 or 3 (vector components).\n    factor : int\n        The factor by which to downsample the field. The dimensions of the field will be divided by this factor.\n    method : str, optional\n        The method to use for downsampling. Default is 'bicubic'.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The downsampled field.\n    \"\"\"\n    if factor == 1:\n        return field\n    else:\n        new_shape = tuple(dim // factor for dim in field.shape[:-1])\n        downsampled_components = []\n        for i in range(field.shape[-1]):  # Iterate over the last dimension (vector components)\n            resized = resize(field[..., i], new_shape, method=method)\n            downsampled_components.append(resized)\n\n        return jnp.stack(downsampled_components, axis=-1)\n</code></pre>"},{"location":"utils/#src.utils.save_image--parameters","title":"Parameters","text":"<p>timestep : int     The timestep at which the field is being saved. fld : jax.numpy.ndarray     The field to be saved. This should be a 2D or 3D JAX array. If the field is 3D, the magnitude of the field will be calculated and saved. prefix : str, optional     A prefix to be added to the filename. The filename will be the name of the main script file by default.</p>"},{"location":"utils/#src.utils.save_image--returns","title":"Returns","text":"<p>None</p>"},{"location":"utils/#src.utils.save_image--notes","title":"Notes","text":"<p>This function saves the field as an image in the PNG format. The filename is based on the name of the main script file, the provided prefix, and the timestep number. If the field is 3D, the magnitude of the field is calculated and saved. The image is saved with the \u2018nipy_spectral\u2019 colormap and the origin set to \u2018lower\u2019.</p> Source code in <code>src/utils.py</code> <pre><code>def save_image(timestep, fld, prefix=None):\n    \"\"\"\n    Save an image of a field at a given timestep.\n\n    Parameters\n    ----------\n    timestep : int\n        The timestep at which the field is being saved.\n    fld : jax.numpy.ndarray\n        The field to be saved. This should be a 2D or 3D JAX array. If the field is 3D, the magnitude of the field will be calculated and saved.\n    prefix : str, optional\n        A prefix to be added to the filename. The filename will be the name of the main script file by default.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This function saves the field as an image in the PNG format. The filename is based on the name of the main script file, the provided prefix, and the timestep number.\n    If the field is 3D, the magnitude of the field is calculated and saved. The image is saved with the 'nipy_spectral' colormap and the origin set to 'lower'.\n    \"\"\"\n    fname = os.path.basename(__main__.__file__)\n    fname = os.path.splitext(fname)[0]\n    if prefix is not None:\n        fname = prefix + fname\n    fname = fname + \"_\" + str(timestep).zfill(4)\n\n    if len(fld.shape) &gt; 3:\n        raise ValueError(\"The input field should be 2D!\")\n    elif len(fld.shape) == 3:\n        fld = np.sqrt(fld[..., 0] ** 2 + fld[..., 1] ** 2)\n\n    plt.clf()\n    plt.imsave(fname + '.png', fld.T, cmap=cm.nipy_spectral, origin='lower')\n</code></pre>"},{"location":"utils/#src.utils.save_fields_vtk--parameters","title":"Parameters","text":"<p>timestep (int): The timestep number to be associated with the saved fields. fields (Dict[str, np.ndarray]): A dictionary of fields to be saved. Each field must be an array-like object      with dimensions (nx, ny) for 2D fields or (nx, ny, nz) for 3D fields, where:         - nx : int, number of grid points along the x-axis         - ny : int, number of grid points along the y-axis         - nz : int, number of grid points along the z-axis (for 3D fields only)     The key value for each field in the dictionary must be a string containing the name of the field. output_dir (str, optional, default: \u2018.\u2019): The directory in which to save the VTK files. Defaults to the current directory. prefix (str, optional, default: \u2018fields\u2019): A prefix to be added to the filename. Defaults to \u2018fields\u2019.</p>"},{"location":"utils/#src.utils.save_fields_vtk--returns","title":"Returns","text":"<p>None</p>"},{"location":"utils/#src.utils.save_fields_vtk--notes","title":"Notes","text":"<p>This function saves the VTK fields in the specified directory, with filenames based on the provided timestep number and the filename. For example, if the timestep number is 10 and the file name is fields, the VTK file will be saved as \u2018fields_0000010.vtk\u2019in the specified directory.</p> Source code in <code>src/utils.py</code> <pre><code>def save_fields_vtk(timestep, fields, output_dir='.', prefix='fields'):\n    \"\"\"\n    Save VTK fields to the specified directory.\n\n    Parameters\n    ----------\n    timestep (int): The timestep number to be associated with the saved fields.\n    fields (Dict[str, np.ndarray]): A dictionary of fields to be saved. Each field must be an array-like object \n        with dimensions (nx, ny) for 2D fields or (nx, ny, nz) for 3D fields, where:\n            - nx : int, number of grid points along the x-axis\n            - ny : int, number of grid points along the y-axis\n            - nz : int, number of grid points along the z-axis (for 3D fields only)\n        The key value for each field in the dictionary must be a string containing the name of the field.\n    output_dir (str, optional, default: '.'): The directory in which to save the VTK files. Defaults to the current directory.\n    prefix (str, optional, default: 'fields'): A prefix to be added to the filename. Defaults to 'fields'.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This function saves the VTK fields in the specified directory, with filenames based on the provided timestep number\n    and the filename. For example, if the timestep number is 10 and the file name is fields, the VTK file\n    will be saved as 'fields_0000010.vtk'in the specified directory.\n\n    \"\"\"\n    # Assert that all fields have the same dimensions except for the last dimension assuming fields is a dictionary\n    for key, value in fields.items():\n        if key == list(fields.keys())[0]:\n            dimensions = value.shape\n        else:\n            assert value.shape == dimensions, \"All fields must have the same dimensions!\"\n\n    output_filename = os.path.join(output_dir, prefix +  \"_\" + f\"{timestep:07d}.vtk\")\n\n    # Add 1 to the dimensions tuple as we store cell values\n    dimensions = tuple([dim + 1 for dim in dimensions])\n\n    # Create a uniform grid\n    if value.ndim == 2:\n        dimensions = dimensions + (1,)\n\n    grid = pv.ImageData(dimensions=dimensions)\n\n    # Add the fields to the grid\n    for key, value in fields.items():\n        grid[key] = value.flatten(order='F')\n\n    # Save the grid to a VTK file\n    start = time()\n    grid.save(output_filename, binary=True)\n    print(f\"Saved {output_filename} in {time() - start:.6f} seconds.\")\n</code></pre>"},{"location":"utils/#src.utils.live_volume_randering--parameters","title":"Parameters","text":"<p>field (np.ndarray): A 3D array containing the field to be rendered.</p>"},{"location":"utils/#src.utils.live_volume_randering--returns","title":"Returns","text":"<p>None</p>"},{"location":"utils/#src.utils.live_volume_randering--notes","title":"Notes","text":"<p>This function uses pyvista to render a 3D volume. The volume is rendered with a colormap based on the field values. The colormap is updated every 0.1 seconds to reflect changes to the field.</p> Source code in <code>src/utils.py</code> <pre><code>def live_volume_randering(timestep, field):\n    # WORK IN PROGRESS\n    \"\"\"\n    Live rendering of a 3D volume using pyvista.\n\n    Parameters\n    ----------\n    field (np.ndarray): A 3D array containing the field to be rendered.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This function uses pyvista to render a 3D volume. The volume is rendered with a colormap based on the field values.\n    The colormap is updated every 0.1 seconds to reflect changes to the field.\n\n    \"\"\"\n    # Create a uniform grid (Note that the field must be 3D) otherwise raise error\n    if field.ndim != 3:\n        raise ValueError(\"The input field must be 3D!\")\n    dimensions = field.shape\n    grid = pv.ImageData(dimensions=dimensions)\n\n    # Add the field to the grid\n    grid['field'] = field.flatten(order='F')\n\n    # Create the rendering scene\n    if timestep == 0:\n        plt.ion()\n        plt.figure(figsize=(10, 10))\n        plt.axis('off')\n        plt.title(\"Live rendering of the field\")\n        pl = pv.Plotter(off_screen=True)\n        pl.add_volume(grid, cmap='nipy_spectral', opacity='sigmoid_10', shade=False)\n        plt.imshow(pl.screenshot())\n\n    else:\n        pl = pv.Plotter(off_screen=True)\n        pl.add_volume(grid, cmap='nipy_spectral', opacity='sigmoid_10', shade=False)\n        # Update the rendering scene every 0.1 seconds\n        plt.imshow(pl.screenshot())\n        plt.pause(0.1)\n</code></pre>"},{"location":"utils/#src.utils.save_BCs_vtk--parameters","title":"Parameters","text":"<p>timestep (int): The timestep number to be associated with the saved fields. BCs (List[BC]): A list of boundary conditions to be saved. Each boundary condition must be an object of type BC.</p>"},{"location":"utils/#src.utils.save_BCs_vtk--returns","title":"Returns","text":"<p>None</p>"},{"location":"utils/#src.utils.save_BCs_vtk--notes","title":"Notes","text":"<p>This function saves the boundary conditions in the specified directory, with filenames based on the provided timestep number and the filename. For example, if the timestep number is 10, the VTK file will be saved as \u2018BCs_0000010.vtk\u2019in the specified directory.</p> Source code in <code>src/utils.py</code> <pre><code>def save_BCs_vtk(timestep, BCs, gridInfo,  output_dir='.'):\n    \"\"\"\n    Save boundary conditions as VTK format to the specified directory.\n\n    Parameters\n    ----------\n    timestep (int): The timestep number to be associated with the saved fields.\n    BCs (List[BC]): A list of boundary conditions to be saved. Each boundary condition must be an object of type BC.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This function saves the boundary conditions in the specified directory, with filenames based on the provided timestep number\n    and the filename. For example, if the timestep number is 10, the VTK file\n    will be saved as 'BCs_0000010.vtk'in the specified directory.\n    \"\"\"\n\n    # Create a uniform grid\n    if gridInfo['nz'] == 0:\n        gridDimensions = (gridInfo['nx'] + 1, gridInfo['ny'] + 1, 1)\n        fieldDimensions = (gridInfo['nx'], gridInfo['ny'], 1)\n    else:\n        gridDimensions = (gridInfo['nx'] + 1, gridInfo['ny'] + 1, gridInfo['nz'] + 1)\n        fieldDimensions = (gridInfo['nx'], gridInfo['ny'], gridInfo['nz'])\n\n    grid = pv.ImageData(dimensions=gridDimensions)\n\n    # Dictionary to keep track of encountered BC names\n    bcNamesCount = {}\n\n    for bc in BCs:\n        bcName = bc.name\n        if bcName in bcNamesCount:\n            bcNamesCount[bcName] += 1\n        else:\n            bcNamesCount[bcName] = 0\n        bcName += f\"_{bcNamesCount[bcName]}\"\n\n        if bc.isDynamic:\n            bcIndices, _ = bc.update_function(timestep)\n        else:\n            bcIndices = bc.indices\n\n        # Convert indices to 1D indices\n        if gridInfo['dim'] == 2:\n            bcIndices = np.ravel_multi_index(bcIndices, fieldDimensions[:-1], order='F')\n        else:\n            bcIndices = np.ravel_multi_index(bcIndices, fieldDimensions, order='F')\n\n        grid[bcName] = np.zeros(fieldDimensions, dtype=bool).flatten(order='F')\n        grid[bcName][bcIndices] = True\n\n    # Save the grid to a VTK file\n    output_filename = os.path.join(output_dir,  \"BCs_\" + f\"{timestep:07d}.vtk\")\n\n    start = time()\n    grid.save(output_filename, binary=True)\n    print(f\"Saved {output_filename} in {time() - start:.6f} seconds.\")\n</code></pre>"},{"location":"utils/#src.utils.rotate_geometry--parameters","title":"Parameters","text":"<p>indices : array-like     The indices of the voxels in the mesh. origin : array-like     The coordinates of the origin of the rotation axis. axis : array-like     The direction vector of the rotation axis. This should be a 3-element sequence. angle : float     The angle by which to rotate the mesh, in radians.</p>"},{"location":"utils/#src.utils.rotate_geometry--returns","title":"Returns","text":"<p>tuple     The indices of the voxels in the rotated mesh.</p>"},{"location":"utils/#src.utils.rotate_geometry--notes","title":"Notes","text":"<p>This function rotates the mesh by applying a rotation matrix to the voxel indices. The rotation matrix is calculated using the axis-angle representation of rotations. The origin of the rotation axis is assumed to be at (0, 0, 0).</p> Source code in <code>src/utils.py</code> <pre><code>def rotate_geometry(indices, origin, axis, angle):\n    \"\"\"\n    Rotates a voxelized mesh around a given axis.\n\n    Parameters\n    ----------\n    indices : array-like\n        The indices of the voxels in the mesh.\n    origin : array-like\n        The coordinates of the origin of the rotation axis.\n    axis : array-like\n        The direction vector of the rotation axis. This should be a 3-element sequence.\n    angle : float\n        The angle by which to rotate the mesh, in radians.\n\n    Returns\n    -------\n    tuple\n        The indices of the voxels in the rotated mesh.\n\n    Notes\n    -----\n    This function rotates the mesh by applying a rotation matrix to the voxel indices. The rotation matrix is calculated\n    using the axis-angle representation of rotations. The origin of the rotation axis is assumed to be at (0, 0, 0).\n    \"\"\"\n    indices_rotated = (jnp.array(indices).T - origin) @ axangle2mat(axis, angle) + origin\n    return tuple(jnp.rint(indices_rotated).astype('int32').T)\n</code></pre>"},{"location":"utils/#src.utils.voxelize_stl--parameters","title":"Parameters","text":"<p>stl_filename : str     The name of the STL file to be voxelized. length_lbm_unit : float, optional     The unit length in LBM. Either this or \u2018pitch\u2019 must be provided. tranformation_matrix : array-like, optional     A transformation matrix to be applied to the mesh before voxelization. pitch : float, optional     The pitch of the voxel grid. Either this or \u2018length_lbm_unit\u2019 must be provided.</p>"},{"location":"utils/#src.utils.voxelize_stl--returns","title":"Returns","text":"<p>trimesh.VoxelGrid, float     The voxelized mesh and the pitch of the voxel grid.</p>"},{"location":"utils/#src.utils.voxelize_stl--notes","title":"Notes","text":"<p>This function uses the trimesh library to load the STL file and voxelized the mesh. If a transformation matrix is provided, it is applied to the mesh before voxelization. The pitch of the voxel grid is calculated based on the maximum extent of the mesh and the provided lattice Boltzmann unit length, unless a pitch is provided directly.</p> Source code in <code>src/utils.py</code> <pre><code>def voxelize_stl(stl_filename, length_lbm_unit=None, tranformation_matrix=None, pitch=None):\n    \"\"\"\n    Converts an STL file to a voxelized mesh.\n\n    Parameters\n    ----------\n    stl_filename : str\n        The name of the STL file to be voxelized.\n    length_lbm_unit : float, optional\n        The unit length in LBM. Either this or 'pitch' must be provided.\n    tranformation_matrix : array-like, optional\n        A transformation matrix to be applied to the mesh before voxelization.\n    pitch : float, optional\n        The pitch of the voxel grid. Either this or 'length_lbm_unit' must be provided.\n\n    Returns\n    -------\n    trimesh.VoxelGrid, float\n        The voxelized mesh and the pitch of the voxel grid.\n\n    Notes\n    -----\n    This function uses the trimesh library to load the STL file and voxelized the mesh. If a transformation matrix is\n    provided, it is applied to the mesh before voxelization. The pitch of the voxel grid is calculated based on the\n    maximum extent of the mesh and the provided lattice Boltzmann unit length, unless a pitch is provided directly.\n    \"\"\"\n    if length_lbm_unit is None and pitch is None:\n        raise ValueError(\"Either 'length_lbm_unit' or 'pitch' must be provided!\")\n    mesh = trimesh.load_mesh(stl_filename, process=False)\n    length_phys_unit = mesh.extents.max()\n    if tranformation_matrix is not None:\n        mesh.apply_transform(tranformation_matrix)\n    if pitch is None:\n        pitch = length_phys_unit / length_lbm_unit\n    mesh_voxelized = mesh.voxelized(pitch=pitch)\n    return mesh_voxelized, pitch\n</code></pre>"}]}